THREAD (extends Thread):
- Klasa dziedziczy po klasie Thread
- Metoda run() jest nadpisywana (@Override)
- Uruchomienie: obiekt.start()
- Ograniczenie: Java nie ma wielodziedziczenia - klasa nie może rozszerzać
  innych klas
- Użycie: gdy nie potrzebujemy dziedziczyć po innych klasach
- Przykład: Watek1_Thread extends Thread

RUNNABLE (implements Runnable):
- Klasa implementuje interfejs Runnable
- Metoda run() jest implementowana
- Uruchomienie: new Thread(obiekt).start()
- Zaleta: klasa może dziedziczyć po innych klasach i implementować
  dodatkowe interfejsy
- Użycie: elastyczniejsze, preferowane w nowoczesnym kodzie Java
- Przykład: Watek2_Runnable implements Runnable

WNIOSKI:
Runnable jest bardziej elastyczny i zgodny z zasadą "preferuj kompozycję
nad dziedziczeniem". Thread jest prostszy dla początkujących, ale ogranicza
możliwości projektowe.

start():
- Uruchamia nowy wątek systemu operacyjnego
- Wywołuje metodę run() w kontekście nowego wątku
- Można wywołać tylko raz na obiekt wątku
- Wątek działa równolegle z innymi wątkami
- PRAWIDŁOWE użycie dla wielowątkowości
- Przykład: thread.start() → uruchamia równoległy wątek

run():
- Zwykła metoda klasy
- Wykonuje się w bieżącym wątku (tym, który ją wywołał)
- Można wywołać wielokrotnie
- Brak równoległości - wykonanie sekwencyjne
- BŁĘDNE użycie dla wielowątkowości (zachowuje się jak zwykła metoda)
- Przykład: thread.run() → wykonuje kod sekwencyjnie w bieżącym wątku

WNIOSKI:
Zawsze używaj start() do uruchamiania wątków! Wywołanie run() bezpośrednio
nie tworzy nowego wątku i powoduje sekwencyjne wykonanie kodu, co całkowicie
niweczy cel programowania wielowątkowego.

PRZYKŁAD BŁĘDU:
thread1.run();  // ŹLE - wykonuje się sekwencyjnie
thread2.run();  // ŹLE - czeka na zakończenie poprzedniego
// Całkowity czas = suma czasów obu wątków

PRZYKŁAD POPRAWNY:
thread1.start();  // DOBRZE - uruchamia równolegle
thread2.start();  // DOBRZE - uruchamia równolegle
// Całkowity czas ≈ czas najdłuższego wątku


================================================================================
SYNCHRONIZACJA
================================================================================

Wszystkie warianty używają synchronizacji do bezpiecznego dostępu do wspólnego
histogramu:

synchronized (histogram) {
    histogram[index] = value;  // lub += value
}

Warianty 3, 4, 5 dodatkowo używają lokalnych histogramów, co redukuje liczbę
synchronizacji - scalanie następuje tylko raz na koniec, a nie po każdym znaku.
To znacząco poprawia wydajność w środowiskach wielowątkowych.


================================================================================
POMIAR WYDAJNOŚCI
================================================================================

Program mierzy czas wykonania w nanosekundach i konwertuje na milisekundy:
- startTime = System.nanoTime()
- [wykonanie obliczeń]
- endTime = System.nanoTime()
- executionTime = (endTime - startTime) / 1e6

Pozwala to porównać efektywność różnych strategii zrównoleglenia.

================================================================================

