<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.editorconfig">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.editorconfig" />
              <option name="updatedContent" value="root = true&#10;&#10;[*]&#10;end_of_line = lf&#10;charset = utf-8&#10;indent_style = space&#10;indent_size = 4&#10;trim_trailing_whitespace = true&#10;insert_final_newline = true&#10;&#10;[*.{java,xml,properties,md,txt}]&#10;indent_size = 4&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="Program automatycznie mierzy czas wykonania wybranego wariantu, co pozwala na porównanie wydajności różnych strategii zrównoleglenia.&#10;&#10;" />
              <option name="updatedContent" value="# Histogram - Wielowątkowe Obliczanie Histogramu&#10;&#10;## Struktura projektu&#10;&#10;Projekt zawiera 5 różnych wariantów zrównoleglenia obliczania histogramu:&#10;&#10;### Wariant 1 (Thread)&#10;- **Klasa**: `Watek1_Thread`&#10;- **Strategia**: Jeden wątek zlicza jeden znak&#10;- **Typ**: Extends Thread&#10;- **Opis**: Każdy wątek jest odpowiedzialny za zliczanie wystąpień jednego konkretnego znaku ASCII w całej tablicy&#10;&#10;### Wariant 2 (Runnable)&#10;- **Klasa**: `Watek2_Runnable`&#10;- **Strategia**: Podział 1D blokowy po znakach&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Znaki ASCII są dzielone na bloki, każdy wątek przetwarza ciągły zakres znaków&#10;&#10;### Wariant 3 (Runnable)&#10;- **Klasa**: `Watek3_Runnable`&#10;- **Strategia**: Podział cykliczny wierszowy po tablicy&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Wiersze tablicy są przydzielane wątkom cyklicznie (wątek 0 -&gt; wiersze 0,3,6..., wątek 1 -&gt; wiersze 1,4,7..., itd.)&#10;&#10;### Wariant 4 (Runnable)&#10;- **Klasa**: `Watek4_Runnable`&#10;- **Strategia**: Podział kolumnowy blokowy po tablicy&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Kolumny tablicy są dzielone na bloki, każdy wątek przetwarza ciągły zakres kolumn&#10;&#10;### Wariant 5 (Runnable)&#10;- **Klasa**: `Watek5_Runnable`&#10;- **Strategia**: Podział 2D blokowy&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Tablica jest dzielona na bloki 2D (prostokąty), każdy wątek przetwarza swój blok&#10;&#10;## Jak uruchomić&#10;&#10;### Kompilacja&#10;```bash&#10;mvn clean compile&#10;```&#10;&#10;### Uruchomienie&#10;```bash&#10;mvn exec:java -Dexec.mainClass=&quot;Histogram_test&quot;&#10;```&#10;&#10;### Interakcja z programem&#10;&#10;1. **Podaj rozmiar obrazu**: n (liczba wierszy), m (liczba kolumn)&#10;   ```&#10;   Set image size: n (#rows), m(#columns)&#10;   10 10&#10;   ```&#10;&#10;2. **Podaj liczbę wątków**:&#10;   ```&#10;   Set number of threads&#10;   4&#10;   ```&#10;&#10;3. **Wybierz wariant** (1-5):&#10;   ```&#10;   Select variant (1-5):&#10;   1 - Thread: jeden wątek zlicza jeden znak&#10;   2 - Runnable: podział 1D blokowy po znakach&#10;   3 - Runnable: podział cykliczny wierszowy&#10;   4 - Runnable: podział kolumnowy blokowy&#10;   5 - Runnable: podział 2D blokowy&#10;   3&#10;   ```&#10;&#10;4. Program wyświetli:&#10;   - Wygenerowaną tablicę znaków&#10;   - Histogram (każdy znak ASCII i liczba jego wystąpień)&#10;   - Czas wykonania obliczeń w milisekundach&#10;&#10;## Przykład użycia&#10;&#10;```&#10;Set image size: n (#rows), m(#columns)&#10;100 100&#10;Set number of threads&#10;8&#10;Select variant (1-5):&#10;3&#10;&#10;[... wygenerowana tablica ...]&#10;&#10;! 105&#10;&quot; 98&#10;# 102&#10;...&#10;~ 107&#10;&#10;Execution time: 15.234 ms&#10;```&#10;&#10;## Synchronizacja&#10;&#10;Wszystkie warianty używają synchronizacji podczas zapisywania wyników do wspólnego histogramu, aby uniknąć wyścigów (race conditions):&#10;- Wariant 1: Synchronizacja przy zapisie pojedynczego wyniku&#10;- Warianty 2-5: Używają lokalnych histogramów i scalają wyniki z synchronizacją&#10;&#10;## Pomiar wydajności&#10;&#10;Program automatycznie mierzy czas wykonania wybranego wariantu, co pozwala na porównanie wydajności różnych strategii zrównoleglenia." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek5_Thread.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek5_Thread.java" />
              <option name="originalContent" value="// Wariant 1: Thread - jeden wątek zlicza jeden znak&#10;public class Watek1_Thread extends Thread {&#10;    private char[][] tab;&#10;    private char[] tab_symb;&#10;    private int[] histogram;&#10;    private int znak_index;&#10;    private int size_n;&#10;    private int size_m;&#10;&#10;    public Watek1_Thread(int znak_index, Obraz obraz) {&#10;        this.znak_index = znak_index;&#10;        this.tab = obraz.getTab();&#10;        this.tab_symb = obraz.getTab_symb();&#10;        this.histogram = obraz.getHistogram();&#10;        this.size_n = obraz.getSize_n();&#10;        this.size_m = obraz.getSize_m();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        char szukany_znak = tab_symb[znak_index];&#10;        int licznik = 0;&#10;&#10;        for (int i = 0; i &lt; size_n; i++) {&#10;            for (int j = 0; j &lt; size_m; j++) {&#10;                if (tab[i][j] == szukany_znak) {&#10;                    licznik++;&#10;                }&#10;            }&#10;        }&#10;&#10;        synchronized (histogram) {&#10;            histogram[znak_index] = licznik;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * Wariant 5: Runnable - podział 2D blokowy&#10; * &#10; * Strategia: Tablica jest dzielona na prostokątne bloki 2D. Każdy wątek&#10; * przetwarza przydzielony blok (zakres wierszy i kolumn).&#10; * &#10; * Zalety: Bardzo dobra lokalność danych, optymalne wykorzystanie cache CPU&#10; * Wady: Wymaga starannego doboru liczby wątków (idealnie kwadraty: 4, 9, 16, ...)&#10; */&#10;public class Watek5_Runnable implements Runnable {&#10;    private char[][] tab;              // Tablica 2D ze znakami obrazu&#10;    private char[] tab_symb;           // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;           // Wspólny histogram (tablica wyników)&#10;    private int start_row;             // Indeks pierwszego wiersza do przetworzenia&#10;    private int end_row;               // Indeks ostatniego wiersza (exclusive)&#10;    private int start_col;             // Indeks pierwszej kolumny do przetworzenia&#10;    private int end_col;               // Indeks ostatniej kolumny (exclusive)&#10;    private int size_n;                // Liczba wierszy tablicy&#10;    private int size_m;                // Liczba kolumn tablicy&#10;    private int[] local_histogram;     // Lokalny histogram dla tego wątku&#10;&#10;    /**&#10;     * Konstruktor wątku&#10;     * @param start_row - indeks pierwszego wiersza bloku&#10;     * @param end_row - indeks ostatniego wiersza bloku (exclusive)&#10;     * @param start_col - indeks pierwszej kolumny bloku&#10;     * @param end_col - indeks ostatniej kolumny bloku (exclusive)&#10;     * @param obraz - obiekt obrazu zawierający dane do przetworzenia&#10;     */&#10;    public Watek5_Runnable(int start_row, int end_row, int start_col, int end_col, Obraz obraz) {&#10;        this.start_row = start_row;&#10;        this.end_row = end_row;&#10;        this.start_col = start_col;&#10;        this.end_col = end_col;&#10;        this.tab = obraz.getTab();&#10;        this.tab_symb = obraz.getTab_symb();&#10;        this.histogram = obraz.getHistogram();&#10;        this.size_n = obraz.getSize_n();&#10;        this.size_m = obraz.getSize_m();&#10;        this.local_histogram = new int[94];  // Lokalny bufor zmniejsza rywalizację o blokadę&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Podział 2D blokowy: przetwarzaj tylko przydzielony prostokątny fragment tablicy&#10;        for (int i = start_row; i &lt; end_row; i++) {&#10;            for (int j = start_col; j &lt; end_col; j++) {&#10;                // Zlicz wszystkie znaki w tym elemencie tablicy&#10;                for (int k = 0; k &lt; 94; k++) {&#10;                    if (tab[i][j] == tab_symb[k]) {&#10;                        local_histogram[k]++;  // Zapis do lokalnego histogramu&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Scalanie wyników: dodaj lokalny histogram do globalnego&#10;        // Synchronizacja tylko raz na koniec, zamiast po każdym znaku&#10;        synchronized (histogram) {&#10;            for (int k = 0; k &lt; 94; k++) {&#10;                histogram[k] += local_histogram[k];&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>