<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="Program automatycznie mierzy czas wykonania wybranego wariantu, co pozwala na porównanie wydajności różnych strategii zrównoleglenia.&#10;&#10;" />
              <option name="updatedContent" value="# Histogram - Wielowątkowe Obliczanie Histogramu&#10;&#10;## Struktura projektu&#10;&#10;Projekt zawiera 5 różnych wariantów zrównoleglenia obliczania histogramu:&#10;&#10;### Wariant 1 (Thread)&#10;- **Klasa**: `Watek1_Thread`&#10;- **Strategia**: Jeden wątek zlicza jeden znak&#10;- **Typ**: Extends Thread&#10;- **Opis**: Każdy wątek jest odpowiedzialny za zliczanie wystąpień jednego konkretnego znaku ASCII w całej tablicy&#10;&#10;### Wariant 2 (Runnable)&#10;- **Klasa**: `Watek2_Runnable`&#10;- **Strategia**: Podział 1D blokowy po znakach&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Znaki ASCII są dzielone na bloki, każdy wątek przetwarza ciągły zakres znaków&#10;&#10;### Wariant 3 (Runnable)&#10;- **Klasa**: `Watek3_Runnable`&#10;- **Strategia**: Podział cykliczny wierszowy po tablicy&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Wiersze tablicy są przydzielane wątkom cyklicznie (wątek 0 -&gt; wiersze 0,3,6..., wątek 1 -&gt; wiersze 1,4,7..., itd.)&#10;&#10;### Wariant 4 (Runnable)&#10;- **Klasa**: `Watek4_Runnable`&#10;- **Strategia**: Podział kolumnowy blokowy po tablicy&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Kolumny tablicy są dzielone na bloki, każdy wątek przetwarza ciągły zakres kolumn&#10;&#10;### Wariant 5 (Runnable)&#10;- **Klasa**: `Watek5_Runnable`&#10;- **Strategia**: Podział 2D blokowy&#10;- **Typ**: Implements Runnable&#10;- **Opis**: Tablica jest dzielona na bloki 2D (prostokąty), każdy wątek przetwarza swój blok&#10;&#10;## Jak uruchomić&#10;&#10;### Kompilacja&#10;```bash&#10;mvn clean compile&#10;```&#10;&#10;### Uruchomienie&#10;```bash&#10;mvn exec:java -Dexec.mainClass=&quot;Histogram_test&quot;&#10;```&#10;&#10;### Interakcja z programem&#10;&#10;1. **Podaj rozmiar obrazu**: n (liczba wierszy), m (liczba kolumn)&#10;   ```&#10;   Set image size: n (#rows), m(#columns)&#10;   10 10&#10;   ```&#10;&#10;2. **Podaj liczbę wątków**:&#10;   ```&#10;   Set number of threads&#10;   4&#10;   ```&#10;&#10;3. **Wybierz wariant** (1-5):&#10;   ```&#10;   Select variant (1-5):&#10;   1 - Thread: jeden wątek zlicza jeden znak&#10;   2 - Runnable: podział 1D blokowy po znakach&#10;   3 - Runnable: podział cykliczny wierszowy&#10;   4 - Runnable: podział kolumnowy blokowy&#10;   5 - Runnable: podział 2D blokowy&#10;   3&#10;   ```&#10;&#10;4. Program wyświetli:&#10;   - Wygenerowaną tablicę znaków&#10;   - Histogram (każdy znak ASCII i liczba jego wystąpień)&#10;   - Czas wykonania obliczeń w milisekundach&#10;&#10;## Przykład użycia&#10;&#10;```&#10;Set image size: n (#rows), m(#columns)&#10;100 100&#10;Set number of threads&#10;8&#10;Select variant (1-5):&#10;3&#10;&#10;[... wygenerowana tablica ...]&#10;&#10;! 105&#10;&quot; 98&#10;# 102&#10;...&#10;~ 107&#10;&#10;Execution time: 15.234 ms&#10;```&#10;&#10;## Synchronizacja&#10;&#10;Wszystkie warianty używają synchronizacji podczas zapisywania wyników do wspólnego histogramu, aby uniknąć wyścigów (race conditions):&#10;- Wariant 1: Synchronizacja przy zapisie pojedynczego wyniku&#10;- Warianty 2-5: Używają lokalnych histogramów i scalają wyniki z synchronizacją&#10;&#10;## Pomiar wydajności&#10;&#10;Program automatycznie mierzy czas wykonania wybranego wariantu, co pozwala na porównanie wydajności różnych strategii zrównoleglenia." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;L6&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;25&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;25&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;L6&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Histogram_test.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Histogram_test.java" />
              <option name="originalContent" value="import java.util.Scanner;&#10;&#10;&#10;public class Histogram_test {&#10;&#10;    public static void main(String[] args) {&#10;&#10;&#9;Scanner scanner = new Scanner(System.in);&#10;&#9;&#10;&#9;System.out.println(&quot;Set image size: n (#rows), m(#kolumns)&quot;);&#10;&#9;int n = scanner.nextInt();&#10;&#9;int m = scanner.nextInt();&#10;&#9;Obraz obraz_1 = new Obraz(n, m);&#10;&#10;&#9;obraz_1.calculate_histogram();&#10;&#9;obraz_1.print_histogram();&#10;&#10;&#9;// System.out.println(&quot;Set number of threads&quot;);&#10;&#9;// int num_threads = scanner.nextInt();&#10;&#10;&#9;// Watek[] NewThr = new Watek[num_threads];&#10;&#10;&#9;// for (int i = 0; i &lt; num_threads; i++) {&#10;&#9;//     (NewThr[i] = new Watek(...,obraz_1)).start();&#10;&#9;// }&#10;&#10;&#9;// for (int i = 0; i &lt; num_threads; i++) {&#10;&#9;//     try {&#10;&#9;// &#9;NewThr[i].join();&#10;&#9;//     } catch (InterruptedException e) {}&#10;&#9;// }&#10;&#10;    }&#10;&#10;}&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="import java.util.Scanner;&#10;&#10;// Program główny do testowania różnych wariantów wielowątkowego obliczania histogramu.&#10;//&#10;// Umożliwia wybór spośród 5 różnych strategii zrównoleglenia:&#10;// 1. Thread - jeden wątek na znak&#10;// 2. Runnable - podział blokowy po znakach&#10;// 3. Runnable - podział cykliczny wierszowy&#10;// 4. Runnable - podział blokowy kolumnowy&#10;// 5. Runnable - podział 2D blokowy&#10;public class Histogram_test {&#10;    &#10;    public static void main(String[] args) {&#10;&#10;&#9;Scanner scanner = new Scanner(System.in);&#10;&#9;&#10;&#9;// Wczytaj liczbę wątków&#10;&#9;System.out.println(&quot;Set number of threads&quot;);&#10;&#9;int numberOfThreads = scanner.nextInt();&#10;&#9;&#10;&#9;// Wczytaj rozmiar obrazu&#10;&#9;System.out.println(&quot;Set image size: n (#rows), m(#columns)&quot;);&#10;&#9;int numberOfRows = scanner.nextInt();&#10;&#9;int numberOfColumns = scanner.nextInt();&#10;&#10;&#9;// Wyświetl menu wyboru wariantu&#10;&#9;System.out.println(&quot;Select variant (1-5):&quot;);&#10;&#9;System.out.println(&quot;1 - Thread: jeden wątek zlicza jeden znak&quot;);&#10;&#9;System.out.println(&quot;2 - Runnable: podział 1D blokowy po znakach&quot;);&#10;&#9;System.out.println(&quot;3 - Runnable: podział cykliczny wierszowy&quot;);&#10;&#9;System.out.println(&quot;4 - Runnable: podział kolumnowy blokowy&quot;);&#10;&#9;System.out.println(&quot;5 - Runnable: podział 2D blokowy&quot;);&#10;&#9;int selectedVariant = scanner.nextInt();&#10;&#10;&#9;// Utwórz obraz z odpowiednią liczbą znaków w zależności od wariantu&#10;&#9;// Wariant 1: ograniczona liczba znaków (numberOfThreads)&#10;&#9;// Warianty 2-5: pełny zakres 94 znaków ASCII&#10;&#9;Obraz image;&#10;&#9;if (selectedVariant == 1) {&#10;&#9;    image = new Obraz(numberOfRows, numberOfColumns, numberOfThreads);  // Ograniczona liczba znaków&#10;&#9;} else {&#10;&#9;    image = new Obraz(numberOfRows, numberOfColumns, 94);  // Pełny zakres znaków&#10;&#9;}&#10;&#10;&#9;// Rozpocznij pomiar czasu&#10;&#9;long startTime = System.nanoTime();&#10;&#10;&#9;// Uruchom wybrany wariant&#10;&#9;switch(selectedVariant) {&#10;&#9;    case 1:&#10;&#9;&#9;runVariant1(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 2:&#10;&#9;&#9;runVariant2(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 3:&#10;&#9;&#9;runVariant3(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 4:&#10;&#9;&#9;runVariant4(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 5:&#10;&#9;&#9;runVariant5(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    default:&#10;&#9;&#9;System.out.println(&quot;Invalid variant! Using sequential version.&quot;);&#10;&#9;&#9;image.calculate_histogram();&#10;&#9;}&#10;&#10;&#9;// Zakończ pomiar czasu&#10;&#9;long endTime = System.nanoTime();&#10;&#9;double executionTime = (endTime - startTime) / 1e6; // konwersja na milisekundy&#10;&#10;&#9;// Wyświetl wyniki&#10;&#9;image.print_histogram();&#10;&#9;System.out.println(&quot;\nExecution time: &quot; + executionTime + &quot; ms&quot;);&#10;&#10;&#9;scanner.close();&#10;    }&#10;&#10;    // Wariant 1: Thread - jeden wątek zlicza jeden znak&#10;    // Tworzy wątki dla każdego możliwego znaku (ograniczone przez numberOfThreads)&#10;    private static void runVariant1(int numberOfThreads, Obraz image) {&#10;&#9;int numberOfCharacters = image.getNumChars();&#10;&#9;System.out.println(&quot;Liczba różnych znaków użytych w obrazie: &quot; + numberOfCharacters);&#10;&#9;&#10;&#9;// Utwórz tablicę wątków - jeden wątek na każdy znak&#10;&#9;Watek1_Thread[] threads = new Watek1_Thread[numberOfCharacters];&#10;&#10;&#9;// Utwórz i uruchom wątki dla wszystkich znaków&#10;&#9;for (int i = 0; i &lt; numberOfCharacters; i++) {&#10;&#9;    threads[i] = new Watek1_Thread(i, image);&#10;&#9;    threads[i].start();&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfCharacters; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 2: Runnable - podział 1D blokowy po znakach&#10;    // Znaki są dzielone na równe bloki między wątki&#10;    private static void runVariant2(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#9;int numberOfCharacters = image.getNumChars();&#10;&#9;int charactersPerThread = numberOfCharacters / numberOfThreads;&#10;&#9;int remainder = numberOfCharacters % numberOfThreads;&#10;&#10;&#9;int startIndex = 0;&#10;&#9;// Utwórz wątki z podziałem bloków znaków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    // Rozdziel resztę z dzielenia między pierwsze wątki&#10;&#9;    int extraCharacters = (i &lt; remainder) ? 1 : 0;&#10;&#9;    int endIndex = startIndex + charactersPerThread + extraCharacters;&#10;&#9;    &#10;&#9;    threads[i] = new Thread(new Watek2_Runnable(startIndex, endIndex, image));&#10;&#9;    threads[i].start();&#10;&#9;    &#10;&#9;    startIndex = endIndex;&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 3: Runnable - podział cykliczny wierszowy&#10;    // Wiersze są przydzielane cyklicznie (round-robin)&#10;    private static void runVariant3(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#10;&#9;// Utwórz wątki - każdy przetwarza co numberOfThreads-ty wiersz&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    threads[i] = new Thread(new Watek3_Runnable(i, numberOfThreads, image));&#10;&#9;    threads[i].start();&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 4: Runnable - podział kolumnowy blokowy&#10;    // Kolumny są dzielone na równe bloki między wątki&#10;    private static void runVariant4(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#9;int numberOfColumns = image.getSize_m();&#10;&#9;int columnsPerThread = numberOfColumns / numberOfThreads;&#10;&#9;int remainder = numberOfColumns % numberOfThreads;&#10;&#10;&#9;int startColumn = 0;&#10;&#9;// Utwórz wątki z podziałem bloków kolumn&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    // Rozdziel resztę z dzielenia między pierwsze wątki&#10;&#9;    int extraColumns = (i &lt; remainder) ? 1 : 0;&#10;&#9;    int endColumn = startColumn + columnsPerThread + extraColumns;&#10;&#9;    &#10;&#9;    threads[i] = new Thread(new Watek4_Runnable(startColumn, endColumn, image));&#10;&#9;    threads[i].start();&#10;&#9;    &#10;&#9;    startColumn = endColumn;&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 5: Runnable - podział 2D blokowy&#10;    // Tablica jest dzielona na prostokątne bloki 2D&#10;    // Liczba wątków jest zaokrąglana do najbliższej siatki (np. 7 wątków -&gt; siatka 2x3 = 6 wątków)&#10;    private static void runVariant5(int numberOfThreads, Obraz image) {&#10;&#9;int numberOfRows = image.getSize_n();&#10;&#9;int numberOfColumns = image.getSize_m();&#10;&#9;&#10;&#9;// Dla prostoty: dzielimy na siatki (np. 2x2, 2x3, itd.)&#10;&#9;// Oblicz optymalny układ wątków w siatce 2D&#10;&#9;int threadsSqrt = (int) Math.sqrt(numberOfThreads);&#10;&#9;int threadsInRows = threadsSqrt;&#10;&#9;int threadsInColumns = (numberOfThreads + threadsSqrt - 1) / threadsSqrt;&#10;&#9;int actualThreadCount = threadsInRows * threadsInColumns;&#10;&#9;&#10;&#9;Thread[] threads = new Thread[actualThreadCount];&#10;&#9;&#10;&#9;int rowsPerThread = numberOfRows / threadsInRows;&#10;&#9;int columnsPerThread = numberOfColumns / threadsInColumns;&#10;&#9;&#10;&#9;int threadIndex = 0;&#10;&#9;// Utwórz wątki dla każdego bloku w siatce 2D&#10;&#9;for (int i = 0; i &lt; threadsInRows; i++) {&#10;&#9;    for (int j = 0; j &lt; threadsInColumns; j++) {&#10;&#9;&#9;// Oblicz granice bloku dla tego wątku&#10;&#9;&#9;int startRow = i * rowsPerThread;&#10;&#9;&#9;int endRow = (i == threadsInRows - 1) ? numberOfRows : (i + 1) * rowsPerThread;&#10;&#9;&#9;int startColumn = j * columnsPerThread;&#10;&#9;&#9;int endColumn = (j == threadsInColumns - 1) ? numberOfColumns : (j + 1) * columnsPerThread;&#10;&#9;&#9;&#10;&#9;&#9;// Utwórz wątek Runnable dla tego bloku&#10;&#9;&#9;threads[threadIndex] = new Thread(new Watek5_Runnable(startRow, endRow, startColumn, endColumn, image));&#10;&#9;&#9;threads[threadIndex].start();&#10;&#9;&#9;threadIndex++;&#10;&#9;    }&#10;&#9;}&#10;&#9;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; actualThreadCount; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Obraz.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Obraz.java" />
              <option name="originalContent" value="import  java.util.Random;&#10;&#10;&#10;public class Obraz {&#10;&#10;    private int size_n;&#10;    private int size_m;&#10;    private char[][] tab;&#10;    private char[] tab_symb;&#10;    private int[] histogram;&#10;&#10;    public Obraz(int n, int m) {&#10;&#10;&#9;this.size_n = n;&#10;&#9;this.size_m = m;&#10;&#9;tab = new char[n][m];&#10;&#9;tab_symb = new char[94];&#10;&#10;&#9;final Random random = new Random();&#10;&#9;&#10;&#9;// for general case where symbols could be not just integers&#10;&#9;for(int k=0;k&lt;94;k++) {&#10;&#9;    tab_symb[k] = (char)(k+33); // substitute symbols&#10;&#9;}&#10;&#10;&#9;for(int i=0;i&lt;n;i++) {&#10;&#9;    for(int j=0;j&lt;m;j++) {&#10;&#9;&#9;tab[i][j] = tab_symb[random.nextInt(94)];  // ascii 33-127&#10;&#9;&#9;//tab[i][j] = (char)(random.nextInt(94)+33);  // ascii 33-127&#10;&#9;&#9;System.out.print(tab[i][j]+&quot; &quot;);&#10;&#9;    }&#10;&#9;    System.out.print(&quot;\n&quot;);&#10;&#9;}&#10;&#9;System.out.print(&quot;\n\n&quot;); &#10;&#9;&#10;&#9;histogram = new int[94];&#10;   &#9;clear_histogram();&#10;    }&#10;    &#10;    public void clear_histogram(){&#10;&#10;&#9;for(int i=0;i&lt;94;i++) histogram[i]=0;&#10;&#10;    }&#10;&#10;    public void calculate_histogram(){&#10;&#10;&#9;  for(int i=0;i&lt;size_n;i++) {&#10;&#9;    for(int j=0;j&lt;size_m;j++) {&#10;&#10;&#9;&#9;// optymalna wersja obliczania histogramu, wykorzystująca fakt, że symbole w tablicy&#10;&#9;&#9;// można przekształcić w indeksy tablicy histogramu&#10;&#9;&#9;// histogram[(int)tab[i][j]-33]++;&#10;&#10;&#9;&#9;// wersja bardziej ogólna dla tablicy symboli nie utożsamianych z indeksami&#10;&#9;&#9;// tylko dla tej wersji sensowne jest zrównoleglenie w dziedzinie zbioru znaków ASCII&#10;&#9;&#9;  for(int k=0;k&lt;94;k++) {&#10;&#9;&#9;    if(tab[i][j] == tab_symb[k]) histogram[k]++;&#10;&#9;&#9;    //if(tab[i][j] == (char)(k+33)) histogram[k]++;&#10;&#9;&#9;  }&#10;&#10;&#9;    }&#10;&#9;  }&#10;&#10;    }&#10;&#10;// uniwersalny wzorzec dla różnych wariantów zrównoleglenia - można go modyfikować dla&#10;// różnych wersji dekompozycji albo stosować tak jak jest zapisane poniżej zmieniając tylko&#10;// parametry wywołania w wątkach&#10;//&#10;//calculate_histogram_wzorzec(start_wiersz, end_wiersz, skok_wiersz,&#10;//                            start_kol, end_kol, skok_kol,&#10;//                            start_znak, end_znak, skok_znak){&#10;//&#10;//  for(int i=start_wiersz;i&lt;end_wiersz;i+=skok_wiersz) {&#10;//     for(int j=start_kol;j&lt;end_kol;j+=skok_kol) {&#10;//        for(int k=start_znak;k&lt;end_znak;k+=skok_znak) {&#10;//           if(tab[i][j] == tab_symb[k]) histogram[k]++;&#10;//&#10;&#10;&#10;    public void print_histogram(){&#10;&#9;&#10;&#9;for(int i=0;i&lt;94;i++) {&#10;&#9;    System.out.print(tab_symb[i]+&quot; &quot;+histogram[i]+&quot;\n&quot;);&#10;&#9;    //System.out.print((char)(i+33)+&quot; &quot;+histogram[i]+&quot;\n&quot;);&#10;&#9;}&#10;&#10;    }&#10;&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="import  java.util.Random;&#10;&#10;// Klasa reprezentująca obraz jako tablicę 2D znaków ASCII.&#10;//&#10;// Obraz składa się z losowo wygenerowanych znaków ASCII (33-126, czyli 94 znaki).&#10;// Klasa umożliwia obliczanie histogramu (liczby wystąpień każdego znaku)&#10;// zarówno sekwencyjnie jak i przez zewnętrzne wątki (za pomocą getterów).&#10;public class Obraz {&#10;&#10;    private int numberOfRows;             // Liczba wierszy tablicy&#10;    private int numberOfColumns;          // Liczba kolumn tablicy&#10;    private char[][] imageTable;          // Tablica 2D zawierająca znaki obrazu&#10;    private char[] symbolsArray;          // Tablica wszystkich możliwych symboli ASCII (ograniczona do numberOfCharacters)&#10;    private int[] histogram;              // Histogram - tablica z liczbą wystąpień każdego znaku&#10;    private int numberOfCharacters;       // Liczba różnych znaków używanych (dla wariantu 1)&#10;&#10;    // Konstruktor - tworzy obraz o zadanych wymiarach i wypełnia go losowymi znakami&#10;    // rows - liczba wierszy&#10;    // columns - liczba kolumn&#10;    // numberOfThreads - liczba wątków (określa ile różnych znaków będzie użytych)&#10;    public Obraz(int rows, int columns, int numberOfThreads) {&#10;&#10;&#9;this.numberOfRows = rows;&#10;&#9;this.numberOfColumns = columns;&#10;&#10;&#9;// Dla wariantu 1: użyj tylko tyle znaków ile wątków (min 1, max 94)&#10;&#9;this.numberOfCharacters = Math.max(1, Math.min(numberOfThreads, 94));&#10;&#10;&#9;imageTable = new char[rows][columns];&#10;&#9;symbolsArray = new char[numberOfCharacters];  // Tylko numberOfCharacters znaków zamiast 94&#10;&#10;&#9;final Random random = new Random();&#10;&#9;&#10;&#9;// Inicjalizacja tablicy symboli ASCII - tylko numberOfCharacters pierwszych znaków&#10;&#9;// 33 = '!', 126 = '~'&#10;&#9;for(int k=0; k&lt;numberOfCharacters; k++) {&#10;&#9;    symbolsArray[k] = (char)(k+33);&#10;&#9;}&#10;&#10;&#9;// Wypełnienie tablicy obrazu losowymi znakami z ograniczonego zbioru&#10;&#9;for(int row=0; row&lt;rows; row++) {&#10;&#9;    for(int col=0; col&lt;columns; col++) {&#10;&#9;&#9;imageTable[row][col] = symbolsArray[random.nextInt(numberOfCharacters)];  // losowy znak z numberOfCharacters znaków&#10;&#9;&#9;System.out.print(imageTable[row][col]+&quot; &quot;);&#10;&#9;    }&#10;&#9;    System.out.print(&quot;\n&quot;);&#10;&#9;}&#10;&#9;System.out.print(&quot;\n\n&quot;); &#10;&#9;&#10;&#9;// Inicjalizacja histogramu - tylko dla używanych znaków&#10;&#9;histogram = new int[numberOfCharacters];&#10;   &#9;clear_histogram();&#10;    }&#10;    &#10;    // Zeruje histogram (ustawia wszystkie wartości na 0)&#10;    public void clear_histogram(){&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) histogram[i]=0;&#10;    }&#10;&#10;    // Sekwencyjna wersja obliczania histogramu.&#10;    // Przeszukuje całą tablicę i zlicza wystąpienia każdego znaku.&#10;    //&#10;    // Uwaga: Ta metoda używa bardziej ogólnego podejścia (porównanie znaków)&#10;    // zamiast optymalnego (bezpośrednie indeksowanie), aby umożliwić&#10;    // zrównoleglenie w dziedzinie znaków ASCII.&#10;    public void calculate_histogram(){&#10;&#10;&#9;  for(int row=0; row&lt;numberOfRows; row++) {&#10;&#9;    for(int col=0; col&lt;numberOfColumns; col++) {&#10;&#10;&#9;&#9;// OPTYMALNA WERSJA (zakomentowana):&#10;&#9;&#9;// Bezpośrednie przekształcenie znaku na indeks histogramu&#10;&#9;&#9;// histogram[(int)imageTable[row][col]-33]++;&#10;&#10;&#9;&#9;// OGÓLNA WERSJA (używana):&#10;&#9;&#9;// Porównanie z każdym znakiem - pozwala na zrównoleglenie po znakach&#10;&#9;&#9;// Wątek może przeszukiwać tablicę dla konkretnego podzbioru znaków&#10;&#9;&#9;  for(int charIndex=0; charIndex&lt;numberOfCharacters; charIndex++) {&#10;&#9;&#9;    if(imageTable[row][col] == symbolsArray[charIndex]) histogram[charIndex]++;&#10;&#9;&#9;  }&#10;&#10;&#9;    }&#10;&#9;  }&#10;&#10;    }&#10;&#10;// UNIWERSALNY WZORZEC dla różnych wariantów zrównoleglenia:&#10;// Można go modyfikować dla różnych strategii dekompozycji albo stosować&#10;// bezpośrednio, zmieniając tylko parametry wywołania w wątkach&#10;//&#10;// calculate_histogram_wzorzec(startRow, endRow, rowStep,&#10;//                              startColumn, endColumn, columnStep,&#10;//                              startCharacter, endCharacter, characterStep){&#10;//&#10;//   for(int row=startRow; row&lt;endRow; row+=rowStep) {&#10;//      for(int col=startColumn; col&lt;endColumn; col+=columnStep) {&#10;//         for(int charIndex=startCharacter; charIndex&lt;endCharacter; charIndex+=characterStep) {&#10;//            if(imageTable[row][col] == symbolsArray[charIndex]) histogram[charIndex]++;&#10;//&#10;// Przykłady użycia wzorca:&#10;// - Podział wierszowy blokowy:    (0, rows/2, 1,   0, columns, 1,   0, 94, 1)&#10;// - Podział wierszowy cykliczny:  (0, rows, 4,     0, columns, 1,   0, 94, 1)  // dla 4 wątków&#10;// - Podział po znakach:           (0, rows, 1,     0, columns, 1,   0, 47, 1)  // pierwsza połowa znaków&#10;&#10;    // Wyświetla histogram - dla każdego znaku ASCII wypisuje jego symbol i liczbę wystąpień&#10;    // Format: 5 kolumn w wierszu dla lepszej czytelności&#10;    public void print_histogram(){&#10;&#9;&#10;&#9;int columnsPerRow = 5;  // Liczba kolumn w wierszu&#10;&#9;&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) {&#10;&#9;    // Wypisz znak i jego liczbę wystąpień&#10;&#9;    System.out.printf(&quot;%c: %-6d\t&quot;, symbolsArray[i], histogram[i]);&#10;&#9;    &#10;&#9;    // Po 5 kolumnach przejdź do nowej linii&#10;&#9;    if ((i + 1) % columnsPerRow == 0) {&#10;&#9;&#9;System.out.println();&#10;&#9;    }&#10;&#9;}&#10;&#9;&#10;&#9;// Jeśli ostatni wiersz nie był pełny, dodaj nową linię&#10;&#9;if (numberOfCharacters % columnsPerRow != 0) {&#10;&#9;    System.out.println();&#10;&#9;}&#10;&#10;    }&#10;&#10;    // Gettery - umożliwiają wątkom dostęp do danych obrazu&#10;    public int getSize_n() { return numberOfRows; }&#10;    public int getSize_m() { return numberOfColumns; }&#10;    public char[][] getTab() { return imageTable; }&#10;    public char[] getTab_symb() { return symbolsArray; }&#10;    public int[] getHistogram() { return histogram; }&#10;    public int getNumChars() { return numberOfCharacters; }  // Zwraca liczbę różnych znaków&#10;&#10;    // Zlicza liczbę unikalnych znaków występujących w obrazie&#10;    public int count_unique_chars() {&#10;        boolean[] found = new boolean[numberOfCharacters];  // Tablica flag dla każdego możliwego znaku&#10;        int count = 0;&#10;&#10;        // Sprawdź które znaki występują w tablicy&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                // Znajdź indeks znaku w tablicy symboli&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex] &amp;&amp; !found[charIndex]) {&#10;                        found[charIndex] = true;&#10;                        count++;&#10;                        break;  // Przerwij wewnętrzną pętlę po znalezieniu znaku&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return count;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek1_Thread.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek1_Thread.java" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Wariant 1: Thread - jeden wątek zlicza jeden znak&#10;//&#10;// Strategia: Każdy wątek odpowiada za zliczanie wystąpień jednego konkretnego&#10;// znaku ASCII w całej tablicy znaków.&#10;//&#10;// Zalety: Prosta implementacja, dobra równowaga obciążenia&#10;// Wady: Maksymalnie 94 wątki (liczba znaków ASCII)&#10;public class Watek1_Thread extends Thread {&#10;    private char[][] imageTable;              // Tablica 2D ze znakami obrazu&#10;    private char[] symbolsArray;              // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;                  // Wspólny histogram (tablica wyników)&#10;    private int characterIndex;               // Indeks znaku, który zlicza ten wątek&#10;    private int numberOfRows;                 // Liczba wierszy tablicy&#10;    private int numberOfColumns;              // Liczba kolumn tablicy&#10;&#10;    // Konstruktor wątku&#10;    // characterIndex - indeks znaku w tablicy symbolsArray, który będzie zliczany&#10;    // image - obiekt obrazu zawierający dane do przetworzenia&#10;    public Watek1_Thread(int characterIndex, Obraz image) {&#10;        this.characterIndex = characterIndex;&#10;        this.imageTable = image.getTab();&#10;        this.symbolsArray = image.getTab_symb();&#10;        this.histogram = image.getHistogram();&#10;        this.numberOfRows = image.getSize_n();&#10;        this.numberOfColumns = image.getSize_m();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Pobierz znak, który ma być zliczany przez ten wątek&#10;        char searchedCharacter = symbolsArray[characterIndex];&#10;        int count = 0;&#10;&#10;        // Przeszukaj całą tablicę i zlicz wystąpienia szukanego znaku&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                if (imageTable[row][col] == searchedCharacter) {&#10;                    count++;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Synchronizacja: bezpieczny zapis wyniku do wspólnego histogramu&#10;        synchronized (histogram) {&#10;            histogram[characterIndex] = count;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek2_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek2_Runnable.java" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Wariant 2: Runnable - podział 1D blokowy po znakach&#10;//&#10;// Strategia: Znaki ASCII są dzielone na bloki. Każdy wątek przetwarza&#10;// ciągły zakres znaków (np. wątek 0: znaki 0-23, wątek 1: znaki 24-47, itd.)&#10;//&#10;// Zalety: Elastyczna liczba wątków, dobra skalowalność&#10;// Wady: Może wystąpić nierównomierne obciążenie jeśli niektóre znaki występują częściej&#10;public class Watek2_Runnable implements Runnable {&#10;    private char[][] imageTable;              // Tablica 2D ze znakami obrazu&#10;    private char[] symbolsArray;              // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;                  // Wspólny histogram (tablica wyników)&#10;    private int startCharacterIndex;          // Indeks pierwszego znaku do zliczenia&#10;    private int endCharacterIndex;            // Indeks ostatniego znaku (exclusive)&#10;    private int numberOfRows;                 // Liczba wierszy tablicy&#10;    private int numberOfColumns;              // Liczba kolumn tablicy&#10;&#10;    // Konstruktor wątku&#10;    // startCharacterIndex - indeks pierwszego znaku do przetworzenia&#10;    // endCharacterIndex - indeks ostatniego znaku (exclusive)&#10;    // image - obiekt obrazu zawierający dane do przetworzenia&#10;    public Watek2_Runnable(int startCharacterIndex, int endCharacterIndex, Obraz image) {&#10;        this.startCharacterIndex = startCharacterIndex;&#10;        this.endCharacterIndex = endCharacterIndex;&#10;        this.imageTable = image.getTab();&#10;        this.symbolsArray = image.getTab_symb();&#10;        this.histogram = image.getHistogram();&#10;        this.numberOfRows = image.getSize_n();&#10;        this.numberOfColumns = image.getSize_m();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Przetwarzaj każdy znak z przydzielonego zakresu&#10;        for (int charIndex = startCharacterIndex; charIndex &lt; endCharacterIndex; charIndex++) {&#10;            char searchedCharacter = symbolsArray[charIndex];&#10;            int count = 0;&#10;&#10;            // Przeszukaj całą tablicę dla bieżącego znaku&#10;            for (int row = 0; row &lt; numberOfRows; row++) {&#10;                for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                    if (imageTable[row][col] == searchedCharacter) {&#10;                        count++;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Synchronizacja: bezpieczny zapis wyniku do wspólnego histogramu&#10;            synchronized (histogram) {&#10;                histogram[charIndex] = count;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek3_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek3_Runnable.java" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Wariant 3: Runnable - podział cykliczny wierszowy po tablicy&#10;//&#10;// Strategia: Wiersze są przydzielane wątkom cyklicznie (round-robin).&#10;// Wątek 0 przetwarza wiersze 0, numberOfThreads, 2*numberOfThreads, ...&#10;// Wątek 1 przetwarza wiersze 1, numberOfThreads+1, 2*numberOfThreads+1, ...&#10;//&#10;// Zalety: Doskonała równowaga obciążenia, unikanie lokalności danych&#10;// Wady: Gorsze wykorzystanie cache procesora&#10;public class Watek3_Runnable implements Runnable {&#10;    private char[][] imageTable;              // Tablica 2D ze znakami obrazu&#10;    private char[] symbolsArray;              // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;                  // Wspólny histogram (tablica wyników)&#10;    private int threadId;                     // Identyfikator wątku (0, 1, 2, ...)&#10;    private int totalThreads;                 // Całkowita liczba wątków&#10;    private int numberOfRows;                 // Liczba wierszy tablicy&#10;    private int numberOfColumns;              // Liczba kolumn tablicy&#10;    private int[] localHistogram;             // Lokalny histogram dla tego wątku&#10;&#10;    // Konstruktor wątku&#10;    // threadId - identyfikator wątku (określa które wiersze przetwarza)&#10;    // totalThreads - całkowita liczba wątków&#10;    // image - obiekt obrazu zawierający dane do przetworzenia&#10;    public Watek3_Runnable(int threadId, int totalThreads, Obraz image) {&#10;        this.threadId = threadId;&#10;        this.totalThreads = totalThreads;&#10;        this.imageTable = image.getTab();&#10;        this.symbolsArray = image.getTab_symb();&#10;        this.histogram = image.getHistogram();&#10;        this.numberOfRows = image.getSize_n();&#10;        this.numberOfColumns = image.getSize_m();&#10;        this.localHistogram = new int[image.getNumChars()];  // Lokalny bufor zmniejsza rywalizację o blokadę&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Podział cykliczny wierszowy: wątek przetwarza co totalThreads-ty wiersz&#10;        for (int row = threadId; row &lt; numberOfRows; row += totalThreads) {&#10;            // Przetwórz wszystkie kolumny w bieżącym wierszu&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                // Zlicz wszystkie znaki w tym elemencie tablicy&#10;                int numberOfCharacters = symbolsArray.length;  // Liczba różnych znaków&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        localHistogram[charIndex]++;  // Zapis do lokalnego histogramu&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Scalanie wyników: dodaj lokalny histogram do globalnego&#10;        // Synchronizacja tylko raz na koniec, zamiast po każdym znaku&#10;        synchronized (histogram) {&#10;            int numberOfCharacters = symbolsArray.length;&#10;            for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                histogram[charIndex] += localHistogram[charIndex];&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek4_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek4_Runnable.java" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Wariant 4: Runnable - podział kolumnowy blokowy po tablicy&#10;//&#10;// Strategia: Kolumny są dzielone na ciągłe bloki. Każdy wątek przetwarza&#10;// przydzielony zakres kolumn dla wszystkich wierszy.&#10;//&#10;// Zalety: Dobra lokalność danych w pamięci, mniej synchronizacji&#10;// Wady: Może wystąpić nierównomierne obciążenie przy nieregularnym rozkładzie danych&#10;public class Watek4_Runnable implements Runnable {&#10;    private char[][] imageTable;              // Tablica 2D ze znakami obrazu&#10;    private char[] symbolsArray;              // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;                  // Wspólny histogram (tablica wyników)&#10;    private int startColumn;                  // Indeks pierwszej kolumny do przetworzenia&#10;    private int endColumn;                    // Indeks ostatniej kolumny (exclusive)&#10;    private int numberOfRows;                 // Liczba wierszy tablicy&#10;    private int numberOfColumns;              // Liczba kolumn tablicy&#10;    private int[] localHistogram;             // Lokalny histogram dla tego wątku&#10;&#10;    // Konstruktor wątku&#10;    // startColumn - indeks pierwszej kolumny do przetworzenia&#10;    // endColumn - indeks ostatniej kolumny (exclusive)&#10;    // image - obiekt obrazu zawierający dane do przetworzenia&#10;    public Watek4_Runnable(int startColumn, int endColumn, Obraz image) {&#10;        this.startColumn = startColumn;&#10;        this.endColumn = endColumn;&#10;        this.imageTable = image.getTab();&#10;        this.symbolsArray = image.getTab_symb();&#10;        this.histogram = image.getHistogram();&#10;        this.numberOfRows = image.getSize_n();&#10;        this.numberOfColumns = image.getSize_m();&#10;        this.localHistogram = new int[image.getNumChars()];  // Lokalny bufor zmniejsza rywalizację o blokadę&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Podział blokowy kolumnowy: przetwarzaj wszystkie wiersze dla przydzielonych kolumn&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            // Przetwórz tylko kolumny z przydzielonego zakresu&#10;            for (int col = startColumn; col &lt; endColumn; col++) {&#10;                // Zlicz wszystkie znaki w tym elemencie tablicy&#10;                int numberOfCharacters = symbolsArray.length;  // Liczba różnych znaków&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        localHistogram[charIndex]++;  // Zapis do lokalnego histogramu&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Scalanie wyników: dodaj lokalny histogram do globalnego&#10;        // Synchronizacja tylko raz na koniec, zamiast po każdym znaku&#10;        synchronized (histogram) {&#10;            int numberOfCharacters = symbolsArray.length;&#10;            for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                histogram[charIndex] += localHistogram[charIndex];&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek5_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek5_Runnable.java" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="// Wariant 5: Runnable - podział 2D blokowy&#10;//&#10;// Strategia: Tablica jest dzielona na prostokątne bloki 2D. Każdy wątek&#10;// przetwarza przydzielony blok (zakres wierszy i kolumn).&#10;//&#10;// Zalety: Bardzo dobra lokalność danych, optymalne wykorzystanie cache CPU&#10;// Wady: Wymaga starannego doboru liczby wątków (idealnie kwadraty: 4, 9, 16, ...)&#10;public class Watek5_Runnable implements Runnable {&#10;    private char[][] imageTable;              // Tablica 2D ze znakami obrazu&#10;    private char[] symbolsArray;              // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;                  // Wspólny histogram (tablica wyników)&#10;    private int startRow;                     // Indeks pierwszego wiersza do przetworzenia&#10;    private int endRow;                       // Indeks ostatniego wiersza (exclusive)&#10;    private int startColumn;                  // Indeks pierwszej kolumny do przetworzenia&#10;    private int endColumn;                    // Indeks ostatniej kolumny (exclusive)&#10;    private int numberOfRows;                 // Liczba wierszy tablicy&#10;    private int numberOfColumns;              // Liczba kolumn tablicy&#10;    private int[] localHistogram;             // Lokalny histogram dla tego wątku&#10;&#10;    // Konstruktor wątku&#10;    // startRow - indeks pierwszego wiersza bloku&#10;    // endRow - indeks ostatniego wiersza bloku (exclusive)&#10;    // startColumn - indeks pierwszej kolumny bloku&#10;    // endColumn - indeks ostatniej kolumny bloku (exclusive)&#10;    // image - obiekt obrazu zawierający dane do przetworzenia&#10;    public Watek5_Runnable(int startRow, int endRow, int startColumn, int endColumn, Obraz image) {&#10;        this.startRow = startRow;&#10;        this.endRow = endRow;&#10;        this.startColumn = startColumn;&#10;        this.endColumn = endColumn;&#10;        this.imageTable = image.getTab();&#10;        this.symbolsArray = image.getTab_symb();&#10;        this.histogram = image.getHistogram();&#10;        this.numberOfRows = image.getSize_n();&#10;        this.numberOfColumns = image.getSize_m();&#10;        this.localHistogram = new int[image.getNumChars()];  // Lokalny bufor zmniejsza rywalizację o blokadę&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Podział 2D blokowy: przetwarzaj tylko przydzielony prostokątny fragment tablicy&#10;        for (int row = startRow; row &lt; endRow; row++) {&#10;            for (int col = startColumn; col &lt; endColumn; col++) {&#10;                // Zlicz wszystkie znaki w tym elemencie tablicy&#10;                int numberOfCharacters = symbolsArray.length;  // Liczba różnych znaków&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        localHistogram[charIndex]++;  // Zapis do lokalnego histogramu&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Scalanie wyników: dodaj lokalny histogram do globalnego&#10;        // Synchronizacja tylko raz na koniec, zamiast po każdym znaku&#10;        synchronized (histogram) {&#10;            int numberOfCharacters = symbolsArray.length;&#10;            for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                histogram[charIndex] += localHistogram[charIndex];&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Watek5_Thread.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Watek5_Thread.java" />
              <option name="originalContent" value="// Wariant 1: Thread - jeden wątek zlicza jeden znak&#10;public class Watek1_Thread extends Thread {&#10;    private char[][] tab;&#10;    private char[] tab_symb;&#10;    private int[] histogram;&#10;    private int znak_index;&#10;    private int size_n;&#10;    private int size_m;&#10;&#10;    public Watek1_Thread(int znak_index, Obraz obraz) {&#10;        this.znak_index = znak_index;&#10;        this.tab = obraz.getTab();&#10;        this.tab_symb = obraz.getTab_symb();&#10;        this.histogram = obraz.getHistogram();&#10;        this.size_n = obraz.getSize_n();&#10;        this.size_m = obraz.getSize_m();&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        char szukany_znak = tab_symb[znak_index];&#10;        int licznik = 0;&#10;&#10;        for (int i = 0; i &lt; size_n; i++) {&#10;            for (int j = 0; j &lt; size_m; j++) {&#10;                if (tab[i][j] == szukany_znak) {&#10;                    licznik++;&#10;                }&#10;            }&#10;        }&#10;&#10;        synchronized (histogram) {&#10;            histogram[znak_index] = licznik;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * Wariant 5: Runnable - podział 2D blokowy&#10; * &#10; * Strategia: Tablica jest dzielona na prostokątne bloki 2D. Każdy wątek&#10; * przetwarza przydzielony blok (zakres wierszy i kolumn).&#10; * &#10; * Zalety: Bardzo dobra lokalność danych, optymalne wykorzystanie cache CPU&#10; * Wady: Wymaga starannego doboru liczby wątków (idealnie kwadraty: 4, 9, 16, ...)&#10; */&#10;public class Watek5_Runnable implements Runnable {&#10;    private char[][] tab;              // Tablica 2D ze znakami obrazu&#10;    private char[] tab_symb;           // Tablica symboli ASCII (94 znaki)&#10;    private int[] histogram;           // Wspólny histogram (tablica wyników)&#10;    private int start_row;             // Indeks pierwszego wiersza do przetworzenia&#10;    private int end_row;               // Indeks ostatniego wiersza (exclusive)&#10;    private int start_col;             // Indeks pierwszej kolumny do przetworzenia&#10;    private int end_col;               // Indeks ostatniej kolumny (exclusive)&#10;    private int size_n;                // Liczba wierszy tablicy&#10;    private int size_m;                // Liczba kolumn tablicy&#10;    private int[] local_histogram;     // Lokalny histogram dla tego wątku&#10;&#10;    /**&#10;     * Konstruktor wątku&#10;     * @param start_row - indeks pierwszego wiersza bloku&#10;     * @param end_row - indeks ostatniego wiersza bloku (exclusive)&#10;     * @param start_col - indeks pierwszej kolumny bloku&#10;     * @param end_col - indeks ostatniej kolumny bloku (exclusive)&#10;     * @param obraz - obiekt obrazu zawierający dane do przetworzenia&#10;     */&#10;    public Watek5_Runnable(int start_row, int end_row, int start_col, int end_col, Obraz obraz) {&#10;        this.start_row = start_row;&#10;        this.end_row = end_row;&#10;        this.start_col = start_col;&#10;        this.end_col = end_col;&#10;        this.tab = obraz.getTab();&#10;        this.tab_symb = obraz.getTab_symb();&#10;        this.histogram = obraz.getHistogram();&#10;        this.size_n = obraz.getSize_n();&#10;        this.size_m = obraz.getSize_m();&#10;        this.local_histogram = new int[94];  // Lokalny bufor zmniejsza rywalizację o blokadę&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        // Podział 2D blokowy: przetwarzaj tylko przydzielony prostokątny fragment tablicy&#10;        for (int i = start_row; i &lt; end_row; i++) {&#10;            for (int j = start_col; j &lt; end_col; j++) {&#10;                // Zlicz wszystkie znaki w tym elemencie tablicy&#10;                for (int k = 0; k &lt; 94; k++) {&#10;                    if (tab[i][j] == tab_symb[k]) {&#10;                        local_histogram[k]++;  // Zapis do lokalnego histogramu&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Scalanie wyników: dodaj lokalny histogram do globalnego&#10;        // Synchronizacja tylko raz na koniec, zamiast po każdym znaku&#10;        synchronized (histogram) {&#10;            for (int k = 0; k &lt; 94; k++) {&#10;                histogram[k] += local_histogram[k];&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>