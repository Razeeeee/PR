<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Programy demonstracyjne - Programowanie Równoległe L7&#10;&#10;## Opis projektu&#10;&#10;Projekt zawiera implementacje różnych wariantów programowania równoległego w Java, demonstrujące:&#10;- ExecutorService i pule wątków&#10;- Interfejs Callable i Future&#10;- Interfejs Runnable z przekazywaniem wyników&#10;- ForkJoinPool do sortowania przez scalanie&#10;- Równoległe obliczanie histogramów&#10;&#10;## Struktura projektu&#10;&#10;### 3.0 - Obliczanie całki&#10;- **CalkaSequential.java** - wariant sekwencyjny z dx przekazanym do konstruktora&#10;- **CalkaCallable.java** - implementacja Callable dla równoległego obliczania segmentu całki&#10;- **CalkaParallel.java** - równoległe obliczanie z ExecutorService, zwracanie wyników przez Future&#10;&#10;### 4.0 - Sortowanie przez scalanie (ForkJoinPool)&#10;- **MergeSortDemo.java** - demonstracja sortowania z wykorzystaniem ForkJoinPool&#10;- **scal_tab.java** - implementacja DivideTask z warunkiem stopu&#10;&#10;### 4.5 - Interfejs Runnable&#10;- **CalkaRunnable.java** - implementacja Runnable z przekazywaniem wyników przez pole obiektu&#10;- **CalkaRunnableParallel.java** - zarządzanie pulą wątków z Runnable&#10;&#10;### 5.0 - Histogram równoległy (ThreadPoolExecutor)&#10;- **HistogramRunnable.java** - lokalne obliczanie histogramu przez wątek&#10;- **HistogramParallel.java** - równoległe obliczanie histogramu z pulą wątków&#10;&#10;### Dodatkowe pliki&#10;- **Obraz.java** - klasa reprezentująca obraz do obliczania histogramu&#10;- **Histogram_test.java** - program z poprzednich zajęć (warianty 1-5)&#10;- **Watek1_Thread.java, Watek2_Runnable.java, Watek3_Runnable.java, Watek4_Runnable.java, Watek5_Runnable.java** - klasy wątków dla różnych wariantów&#10;&#10;## Kompilacja&#10;&#10;```bash&#10;mvn clean compile&#10;```&#10;&#10;## Uruchomienie&#10;&#10;```bash&#10;mvn exec:java&#10;```&#10;&#10;Lub bezpośrednio:&#10;```bash&#10;java -cp target/classes org.example.Main&#10;```&#10;&#10;## Menu programu&#10;&#10;Po uruchomieniu pojawi się interaktywne menu:&#10;&#10;```&#10;=== MENU DEMONSTRACJI PROGRAMOWANIA RÓWNOLEGŁEGO ===&#10;3.0 - Obliczanie całki (sekwencyjne i równoległe)&#10;4.0 - Sortowanie przez scalanie (ForkJoinPool)&#10;4.5 - Obliczanie całki z interfejsem Runnable&#10;5.0 - Histogram równoległy (pula wątków)&#10;0   - Wyjście&#10;```&#10;&#10;## Przykłady użycia&#10;&#10;### Opcja 3.0 - Obliczanie całki&#10;Program poprosi o:&#10;- Dolną granicę całkowania (a): np. 0&#10;- Górną granicę całkowania (b): np. 10&#10;- Krok całkowania (dx): np. 0.0001&#10;- Liczbę wątków: np. 4&#10;&#10;Wyświetli:&#10;- Wynik sekwencyjny i czas wykonania&#10;- Wynik równoległy i czas wykonania&#10;- Porównanie z wartością analityczną&#10;&#10;### Opcja 4.0 - Sortowanie przez scalanie&#10;Program poprosi o:&#10;- Rozmiar tablicy: np. 10000&#10;- Zakres wartości (max): np. 1000&#10;&#10;Wyświetli:&#10;- Tablicę przed i po sortowaniu (lub fragment dla dużych tablic)&#10;- Czas sortowania&#10;- Weryfikację poprawności sortowania&#10;&#10;### Opcja 4.5 - Całka z Runnable&#10;Program poprosi o:&#10;- Parametry całkowania (a, b, dx)&#10;- Liczbę wątków&#10;&#10;Wyniki są przekazywane przez pola obiektów Runnable zamiast Future.&#10;&#10;### Opcja 5.0 - Histogram równoległy&#10;Program poprosi o:&#10;- Rozmiar danych: np. 1000000&#10;- Zakres wartości (0 - max): np. 255&#10;- Liczbę przedziałów histogramu: np. 10&#10;- Liczbę wątków: np. 4&#10;&#10;Wyświetli:&#10;- Histogram graficzny&#10;- Czas obliczeń&#10;- Weryfikację poprawności (suma elementów)&#10;&#10;## Kluczowe koncepcje&#10;&#10;### ExecutorService&#10;Używany w CalkaParallel.java do zarządzania pulą wątków:&#10;```java&#10;ExecutorService executor = Executors.newFixedThreadPool(numThreads);&#10;```&#10;&#10;### Callable i Future&#10;Pozwala na pobieranie wyników z zadań asynchronicznych:&#10;```java&#10;Future&lt;Double&gt; future = executor.submit(task);&#10;double result = future.get(); // Blokuje do otrzymania wyniku&#10;```&#10;&#10;### Runnable z przekazywaniem wyników&#10;Alternatywne podejście bez Future:&#10;```java&#10;CalkaRunnable task = new CalkaRunnable(a, b, dx);&#10;executor.execute(task);&#10;executor.awaitTermination(1, TimeUnit.MINUTES);&#10;double result = task.getResult();&#10;```&#10;&#10;### ForkJoinPool&#10;Strategia &quot;dziel i rządź&quot; dla sortowania:&#10;```java&#10;ForkJoinPool pool = new ForkJoinPool();&#10;int[] result = pool.invoke(new DivideTask(array));&#10;```&#10;&#10;## Synchronizacja&#10;&#10;W klasie Obraz metody obliczające histogram używają synchronizacji:&#10;- `synchronized` na całej metodzie (wariant 1)&#10;- `synchronized(histogram)` dla bloków krytycznych (warianty 2-5)&#10;&#10;## Autor&#10;&#10;Projekt laboratoryjny L7 - Programowanie Równoległe&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;L7&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;21&lt;/source&gt;&#10;                    &lt;target&gt;21&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;&#10;                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.1.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;mainClass&gt;org.example.Main&lt;/mainClass&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/CalkaCallable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/CalkaCallable.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.concurrent.Callable;&#10;&#10;public class CalkaCallable implements Callable&lt;Double&gt; {&#10;    &#10;    private double a; // lower bound for this segment&#10;    private double b; // upper bound for this segment&#10;    private double dx;&#10;    &#10;    public CalkaCallable(double a, double b, double dx) {&#10;        this.a = a;&#10;        this.b = b;&#10;        this.dx = dx;&#10;    }&#10;    &#10;    @Override&#10;    public Double call() throws Exception {&#10;        double result = 0.0;&#10;        int n = (int) Math.ceil((b - a) / dx);&#10;        &#10;        for (int i = 0; i &lt; n; i++) {&#10;            double x = a + i * dx;&#10;            result += function(x) * dx;&#10;        }&#10;        &#10;        return result;&#10;    }&#10;    &#10;    // Example function: f(x) = x^2&#10;    private double function(double x) {&#10;        return x * x;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/CalkaParallel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/CalkaParallel.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ExecutionException;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.Future;&#10;&#10;public class CalkaParallel {&#10;    &#10;    private double a; // lower bound&#10;    private double b; // upper bound&#10;    private double dx;&#10;    private int numThreads;&#10;    &#10;    public CalkaParallel(double a, double b, double dx, int numThreads) {&#10;        this.a = a;&#10;        this.b = b;&#10;        this.dx = dx;&#10;        this.numThreads = numThreads;&#10;    }&#10;    &#10;    public double calculate() throws InterruptedException, ExecutionException {&#10;        ExecutorService executor = Executors.newFixedThreadPool(numThreads);&#10;        List&lt;Future&lt;Double&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;        &#10;        // Divide the integration range into segments&#10;        double segmentSize = (b - a) / numThreads;&#10;        &#10;        for (int i = 0; i &lt; numThreads; i++) {&#10;            double segmentA = a + i * segmentSize;&#10;            double segmentB = (i == numThreads - 1) ? b : a + (i + 1) * segmentSize;&#10;            &#10;            CalkaCallable task = new CalkaCallable(segmentA, segmentB, dx);&#10;            Future&lt;Double&gt; future = executor.submit(task);&#10;            futures.add(future);&#10;        }&#10;        &#10;        // Collect results from all threads&#10;        double totalResult = 0.0;&#10;        for (Future&lt;Double&gt; future : futures) {&#10;            totalResult += future.get(); // This blocks until the result is available&#10;        }&#10;        &#10;        executor.shutdown();&#10;        &#10;        return totalResult;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/CalkaRunnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/CalkaRunnable.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class CalkaRunnable implements Runnable {&#10;    &#10;    private double a; // lower bound for this segment&#10;    private double b; // upper bound for this segment&#10;    private double dx;&#10;    private double result;&#10;    &#10;    public CalkaRunnable(double a, double b, double dx) {&#10;        this.a = a;&#10;        this.b = b;&#10;        this.dx = dx;&#10;        this.result = 0.0;&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        result = 0.0;&#10;        int n = (int) Math.ceil((b - a) / dx);&#10;        &#10;        for (int i = 0; i &lt; n; i++) {&#10;            double x = a + i * dx;&#10;            result += function(x) * dx;&#10;        }&#10;    }&#10;    &#10;    // Example function: f(x) = x^2&#10;    private double function(double x) {&#10;        return x * x;&#10;    }&#10;    &#10;    public double getResult() {&#10;        return result;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/CalkaRunnableParallel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/CalkaRunnableParallel.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;public class CalkaRunnableParallel {&#10;    &#10;    private double a; // lower bound&#10;    private double b; // upper bound&#10;    private double dx;&#10;    private int numThreads;&#10;    &#10;    public CalkaRunnableParallel(double a, double b, double dx, int numThreads) {&#10;        this.a = a;&#10;        this.b = b;&#10;        this.dx = dx;&#10;        this.numThreads = numThreads;&#10;    }&#10;    &#10;    public double calculate() throws InterruptedException {&#10;        ExecutorService executor = Executors.newFixedThreadPool(numThreads);&#10;        List&lt;CalkaRunnable&gt; tasks = new ArrayList&lt;&gt;();&#10;        &#10;        // Divide the integration range into segments&#10;        double segmentSize = (b - a) / numThreads;&#10;        &#10;        for (int i = 0; i &lt; numThreads; i++) {&#10;            double segmentA = a + i * segmentSize;&#10;            double segmentB = (i == numThreads - 1) ? b : a + (i + 1) * segmentSize;&#10;            &#10;            CalkaRunnable task = new CalkaRunnable(segmentA, segmentB, dx);&#10;            tasks.add(task);&#10;            executor.execute(task);&#10;        }&#10;        &#10;        executor.shutdown();&#10;        executor.awaitTermination(1, TimeUnit.MINUTES);&#10;        &#10;        // Collect results from all threads&#10;        double totalResult = 0.0;&#10;        for (CalkaRunnable task : tasks) {&#10;            totalResult += task.getResult();&#10;        }&#10;        &#10;        return totalResult;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/CalkaSequential.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/CalkaSequential.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class CalkaSequential {&#10;    &#10;    private double dx;&#10;    private double a; // lower bound&#10;    private double b; // upper bound&#10;    &#10;    public CalkaSequential(double a, double b, double dx) {&#10;        this.a = a;&#10;        this.b = b;&#10;        this.dx = dx;&#10;    }&#10;    &#10;    public double calculate() {&#10;        double result = 0.0;&#10;        int n = (int) Math.ceil((b - a) / dx);&#10;        &#10;        for (int i = 0; i &lt; n; i++) {&#10;            double x = a + i * dx;&#10;            result += function(x) * dx;&#10;        }&#10;        &#10;        return result;&#10;    }&#10;    &#10;    // Example function: f(x) = x^2&#10;    private double function(double x) {&#10;        return x * x;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/HistogramParallel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/HistogramParallel.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;public class HistogramParallel {&#10;    &#10;    private int[] data;&#10;    private int numBins;&#10;    private int numThreads;&#10;    private int minValue;&#10;    private int maxValue;&#10;    &#10;    public HistogramParallel(int[] data, int numBins, int numThreads) {&#10;        this.data = data;&#10;        this.numBins = numBins;&#10;        this.numThreads = numThreads;&#10;        &#10;        // Find min and max values&#10;        this.minValue = data[0];&#10;        this.maxValue = data[0];&#10;        for (int value : data) {&#10;            if (value &lt; minValue) minValue = value;&#10;            if (value &gt; maxValue) maxValue = value;&#10;        }&#10;    }&#10;    &#10;    public int[] calculate() throws InterruptedException {&#10;        ExecutorService executor = Executors.newFixedThreadPool(numThreads);&#10;        List&lt;HistogramRunnable&gt; tasks = new ArrayList&lt;&gt;();&#10;        &#10;        int segmentSize = data.length / numThreads;&#10;        &#10;        for (int i = 0; i &lt; numThreads; i++) {&#10;            int startIndex = i * segmentSize;&#10;            int endIndex = (i == numThreads - 1) ? data.length : (i + 1) * segmentSize;&#10;            &#10;            HistogramRunnable task = new HistogramRunnable(&#10;                data, startIndex, endIndex, numBins, minValue, maxValue&#10;            );&#10;            tasks.add(task);&#10;            executor.execute(task);&#10;        }&#10;        &#10;        executor.shutdown();&#10;        executor.awaitTermination(1, TimeUnit.MINUTES);&#10;        &#10;        // Merge local histograms&#10;        int[] globalHistogram = new int[numBins];&#10;        for (HistogramRunnable task : tasks) {&#10;            int[] localHist = task.getLocalHistogram();&#10;            for (int i = 0; i &lt; numBins; i++) {&#10;                globalHistogram[i] += localHist[i];&#10;            }&#10;        }&#10;        &#10;        return globalHistogram;&#10;    }&#10;    &#10;    public void printHistogram(int[] histogram) {&#10;        System.out.println(&quot;\nHistogram (Min: &quot; + minValue + &quot;, Max: &quot; + maxValue + &quot;):&quot;);&#10;        int binWidth = (maxValue - minValue + 1) / numBins;&#10;        for (int i = 0; i &lt; histogram.length; i++) {&#10;            int rangeStart = minValue + i * binWidth;&#10;            int rangeEnd = (i == numBins - 1) ? maxValue : rangeStart + binWidth - 1;&#10;            System.out.printf(&quot;[%4d - %4d]: %s (%d)\n&quot;, &#10;                rangeStart, rangeEnd, &quot;*&quot;.repeat(Math.min(histogram[i], 50)), histogram[i]);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/HistogramRunnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/HistogramRunnable.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class HistogramRunnable implements Runnable {&#10;    &#10;    private int[] data;&#10;    private int startIndex;&#10;    private int endIndex;&#10;    private int[] localHistogram;&#10;    private int numBins;&#10;    private int minValue;&#10;    private int maxValue;&#10;    &#10;    public HistogramRunnable(int[] data, int startIndex, int endIndex, &#10;                            int numBins, int minValue, int maxValue) {&#10;        this.data = data;&#10;        this.startIndex = startIndex;&#10;        this.endIndex = endIndex;&#10;        this.numBins = numBins;&#10;        this.minValue = minValue;&#10;        this.maxValue = maxValue;&#10;        this.localHistogram = new int[numBins];&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        for (int i = startIndex; i &lt; endIndex; i++) {&#10;            int value = data[i];&#10;            if (value &gt;= minValue &amp;&amp; value &lt;= maxValue) {&#10;                int bin = (int) (((double)(value - minValue) / (maxValue - minValue + 1)) * numBins);&#10;                if (bin &gt;= numBins) bin = numBins - 1;&#10;                localHistogram[bin]++;&#10;            }&#10;        }&#10;    }&#10;    &#10;    public int[] getLocalHistogram() {&#10;        return localHistogram;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Histogram_test.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Histogram_test.java" />
              <option name="originalContent" value="import java.util.Scanner;&#10;&#10;// 1. Thread - jeden wątek na znak&#10;// 2. Runnable - podział blokowy po znakach&#10;// 3. Runnable - podział cykliczny wierszowy&#10;// 4. Runnable - podział kolumnowy blokowy&#10;// 5. Runnable - podział 2D blokowy&#10;public class Histogram_test {&#10;&#10;    public static void main(String[] args) {&#10;&#10;&#9;Scanner scanner = new Scanner(System.in);&#10;&#9;&#10;&#9;// Wczytaj liczbę wątków&#10;&#9;System.out.println(&quot;Set number of threads&quot;);&#10;&#9;int numberOfThreads = scanner.nextInt();&#10;&#10;&#9;// Wczytaj rozmiar obrazu&#10;&#9;System.out.println(&quot;Set image size: n (#rows), m(#columns)&quot;);&#10;&#9;int numberOfRows = scanner.nextInt();&#10;&#9;int numberOfColumns = scanner.nextInt();&#10;&#10;&#9;// Wyświetl menu wyboru wariantu&#10;&#9;System.out.println(&quot;1 - Thread: jeden wątek zlicza jeden znak&quot;);&#10;&#9;System.out.println(&quot;2 - Runnable: podział 1D blokowy po znakach&quot;);&#10;&#9;System.out.println(&quot;3 - Runnable: podział cykliczny wierszowy&quot;);&#10;&#9;System.out.println(&quot;4 - Runnable: podział kolumnowy blokowy&quot;);&#10;&#9;System.out.println(&quot;5 - Runnable: podział 2D blokowy&quot;);&#10;&#9;int selectedVariant = scanner.nextInt();&#10;&#10;&#9;// Utwórz obraz z odpowiednią liczbą znaków w zależności od wariantu&#10;&#9;// Wariant 1: ograniczona liczba znaków (numberOfThreads)&#10;&#9;// Warianty 2-5: pełny zakres 94 znaków ASCII&#10;&#9;Obraz image;&#10;&#9;if (selectedVariant == 1) {&#10;&#9;    image = new Obraz(numberOfRows, numberOfColumns, numberOfThreads);  // Ograniczona liczba znaków&#10;&#9;} else {&#10;&#9;    image = new Obraz(numberOfRows, numberOfColumns, 94);  // Pełny zakres znaków&#10;&#9;}&#10;&#10;&#9;// Rozpocznij pomiar czasu&#10;&#9;long startTime = System.nanoTime();&#10;&#10;&#9;// Uruchom wybrany wariant&#10;&#9;switch(selectedVariant) {&#10;&#9;    case 1:&#10;&#9;&#9;runVariant1(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 2:&#10;&#9;&#9;runVariant2(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 3:&#10;&#9;&#9;runVariant3(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 4:&#10;&#9;&#9;runVariant4(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 5:&#10;&#9;&#9;runVariant5(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    default:&#10;&#9;&#9;System.out.println(&quot;Invalid variant! Using sequential version.&quot;);&#10;&#9;&#9;image.calculate_histogram();&#10;&#9;}&#10;&#10;&#9;// Zakończ pomiar czasu&#10;&#9;long endTime = System.nanoTime();&#10;&#9;double executionTime = (endTime - startTime) / 1e6; // konwersja na milisekundy&#10;&#10;&#9;// Wyświetl wyniki - normalny histogram&#10;&#9;image.print_histogram();&#10;&#10;&#9;// Dla wariantów 2-5 dodatkowo wypisz histogram z odfiltrowanymi zerami&#10;&#9;if (selectedVariant &gt;= 2 &amp;&amp; selectedVariant &lt;= 5) {&#10;&#9;    // Pozwól metodzie print_histogram_filtered sama wypisać nagłówek&#10;&#9;    image.print_histogram_filtered();&#10;&#9;}&#10;&#10;&#9;System.out.println(&quot;\nExecution time: &quot; + executionTime + &quot; ms&quot;);&#10;&#10;&#9;scanner.close();&#10;    }&#10;&#10;    // Wariant 1: Thread - jeden wątek zlicza jeden znak&#10;    // Tworzy wątki dla każdego możliwego znaku (ograniczone przez numberOfThreads)&#10;    private static void runVariant1(int numberOfThreads, Obraz image) {&#10;&#9;int numberOfCharacters = image.getNumChars();&#10;&#9;System.out.println(&quot;Liczba różnych znaków użytych w obrazie: &quot; + numberOfCharacters);&#10;&#10;&#9;// Utwórz tablicę wątków - jeden wątek na każdy znak&#10;&#9;Watek1_Thread[] threads = new Watek1_Thread[numberOfCharacters];&#10;&#10;&#9;// Utwórz i uruchom wątki dla wszystkich znaków&#10;&#9;for (int i = 0; i &lt; numberOfCharacters; i++) {&#10;&#9;    threads[i] = new Watek1_Thread(i, image);&#10;&#9;    threads[i].start();&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfCharacters; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 2: Runnable - podział 1D blokowy po znakach&#10;    // Znaki są dzielone na równe bloki między wątki&#10;    private static void runVariant2(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#9;int numberOfCharacters = image.getNumChars();&#10;&#9;int charactersPerThread = numberOfCharacters / numberOfThreads;&#10;&#9;int remainder = numberOfCharacters % numberOfThreads;&#10;&#10;&#9;int startIndex = 0;&#10;&#9;// Utwórz wątki z podziałem bloków znaków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    // Rozdziel resztę z dzielenia między pierwsze wątki&#10;&#9;    int extraCharacters = (i &lt; remainder) ? 1 : 0;&#10;&#9;    int endIndex = startIndex + charactersPerThread + extraCharacters;&#10;&#10;&#9;    threads[i] = new Thread(new Watek2_Runnable(startIndex, endIndex, image));&#10;&#9;    threads[i].start();&#10;&#10;&#9;    startIndex = endIndex;&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 3: Runnable - podział cykliczny wierszowy&#10;    // Wiersze są przydzielane cyklicznie (round-robin)&#10;    private static void runVariant3(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#10;&#9;// Utwórz wątki - każdy przetwarza co numberOfThreads-ty wiersz&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    threads[i] = new Thread(new Watek3_Runnable(i, numberOfThreads, image));&#10;&#9;    threads[i].start();&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 4: Runnable - podział kolumnowy blokowy&#10;    // Kolumny są dzielone na równe bloki między wątki&#10;    private static void runVariant4(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#9;int numberOfColumns = image.getSize_m();&#10;&#9;int columnsPerThread = numberOfColumns / numberOfThreads;&#10;&#9;int remainder = numberOfColumns % numberOfThreads;&#10;&#10;&#9;int startColumn = 0;&#10;&#9;// Utwórz wątki z podziałem bloków kolumn&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    // Rozdziel resztę z dzielenia między pierwsze wątki&#10;&#9;    int extraColumns = (i &lt; remainder) ? 1 : 0;&#10;&#9;    int endColumn = startColumn + columnsPerThread + extraColumns;&#10;&#10;&#9;    threads[i] = new Thread(new Watek4_Runnable(startColumn, endColumn, image));&#10;&#9;    threads[i].start();&#10;&#10;&#9;    startColumn = endColumn;&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 5: Runnable - podział 2D blokowy&#10;    // Tablica jest dzielona na prostokątne bloki 2D&#10;    // Liczba wątków jest zaokrąglana do najbliższej siatki (np. 7 wątków -&gt; siatka 2x3 = 6 wątków)&#10;    private static void runVariant5(int numberOfThreads, Obraz image) {&#10;&#9;int numberOfRows = image.getSize_n();&#10;&#9;int numberOfColumns = image.getSize_m();&#10;&#10;&#9;// Dla prostoty: dzielimy na siatki (np. 2x2, 2x3, itd.)&#10;&#9;// Oblicz optymalny układ wątków w siatce 2D&#10;&#9;int threadsSqrt = (int) Math.sqrt(numberOfThreads);&#10;&#9;int threadsInRows = threadsSqrt;&#10;&#9;int threadsInColumns = (numberOfThreads + threadsSqrt - 1) / threadsSqrt;&#10;&#9;int actualThreadCount = threadsInRows * threadsInColumns;&#10;&#10;&#9;Thread[] threads = new Thread[actualThreadCount];&#10;&#10;&#9;int rowsPerThread = numberOfRows / threadsInRows;&#10;&#9;int columnsPerThread = numberOfColumns / threadsInColumns;&#10;&#10;&#9;int threadIndex = 0;&#10;&#9;// Utwórz wątki dla każdego bloku w siatce 2D&#10;&#9;for (int i = 0; i &lt; threadsInRows; i++) {&#10;&#9;    for (int j = 0; j &lt; threadsInColumns; j++) {&#10;&#9;&#9;// Oblicz granice bloku dla tego wątku&#10;&#9;&#9;int startRow = i * rowsPerThread;&#10;&#9;&#9;int endRow = (i == threadsInRows - 1) ? numberOfRows : (i + 1) * rowsPerThread;&#10;&#9;&#9;int startColumn = j * columnsPerThread;&#10;&#9;&#9;int endColumn = (j == threadsInColumns - 1) ? numberOfColumns : (j + 1) * columnsPerThread;&#10;&#10;&#9;&#9;// Utwórz wątek Runnable dla tego bloku&#10;&#9;&#9;threads[threadIndex] = new Thread(new Watek5_Runnable(startRow, endRow, startColumn, endColumn, image));&#10;&#9;&#9;threads[threadIndex].start();&#10;&#9;&#9;threadIndex++;&#10;&#9;    }&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; actualThreadCount; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.Scanner;&#10;&#10;// 1. Thread - jeden wątek na znak&#10;// 2. Runnable - podział blokowy po znakach&#10;// 3. Runnable - podział cykliczny wierszowy&#10;// 4. Runnable - podział kolumnowy blokowy&#10;// 5. Runnable - podział 2D blokowy&#10;public class Histogram_test {&#10;&#10;    public static void main(String[] args) {&#10;&#10;&#9;Scanner scanner = new Scanner(System.in);&#10;&#9;&#10;&#9;// Wczytaj liczbę wątków&#10;&#9;System.out.println(&quot;Set number of threads&quot;);&#10;&#9;int numberOfThreads = scanner.nextInt();&#10;&#10;&#9;// Wczytaj rozmiar obrazu&#10;&#9;System.out.println(&quot;Set image size: n (#rows), m(#columns)&quot;);&#10;&#9;int numberOfRows = scanner.nextInt();&#10;&#9;int numberOfColumns = scanner.nextInt();&#10;&#10;&#9;// Wyświetl menu wyboru wariantu&#10;&#9;System.out.println(&quot;1 - Thread: jeden wątek zlicza jeden znak&quot;);&#10;&#9;System.out.println(&quot;2 - Runnable: podział 1D blokowy po znakach&quot;);&#10;&#9;System.out.println(&quot;3 - Runnable: podział cykliczny wierszowy&quot;);&#10;&#9;System.out.println(&quot;4 - Runnable: podział kolumnowy blokowy&quot;);&#10;&#9;System.out.println(&quot;5 - Runnable: podział 2D blokowy&quot;);&#10;&#9;int selectedVariant = scanner.nextInt();&#10;&#10;&#9;// Utwórz obraz z odpowiednią liczbą znaków w zależności od wariantu&#10;&#9;// Wariant 1: ograniczona liczba znaków (numberOfThreads)&#10;&#9;// Warianty 2-5: pełny zakres 94 znaków ASCII&#10;&#9;Obraz image;&#10;&#9;if (selectedVariant == 1) {&#10;&#9;    image = new Obraz(numberOfRows, numberOfColumns, numberOfThreads);  // Ograniczona liczba znaków&#10;&#9;} else {&#10;&#9;    image = new Obraz(numberOfRows, numberOfColumns, 94);  // Pełny zakres znaków&#10;&#9;}&#10;&#10;&#9;// Rozpocznij pomiar czasu&#10;&#9;long startTime = System.nanoTime();&#10;&#10;&#9;// Uruchom wybrany wariant&#10;&#9;switch(selectedVariant) {&#10;&#9;    case 1:&#10;&#9;&#9;runVariant1(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 2:&#10;&#9;&#9;runVariant2(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 3:&#10;&#9;&#9;runVariant3(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 4:&#10;&#9;&#9;runVariant4(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    case 5:&#10;&#9;&#9;runVariant5(numberOfThreads, image);&#10;&#9;&#9;break;&#10;&#9;    default:&#10;&#9;&#9;System.out.println(&quot;Invalid variant! Using sequential version.&quot;);&#10;&#9;&#9;image.calculate_histogram();&#10;&#9;}&#10;&#10;&#9;// Zakończ pomiar czasu&#10;&#9;long endTime = System.nanoTime();&#10;&#9;double executionTime = (endTime - startTime) / 1e6; // konwersja na milisekundy&#10;&#10;&#9;// Wyświetl wyniki - normalny histogram&#10;&#9;image.print_histogram();&#10;&#10;&#9;// Dla wariantów 2-5 dodatkowo wypisz histogram z odfiltrowanymi zerami&#10;&#9;if (selectedVariant &gt;= 2 &amp;&amp; selectedVariant &lt;= 5) {&#10;&#9;    // Pozwól metodzie print_histogram_filtered sama wypisać nagłówek&#10;&#9;    image.print_histogram_filtered();&#10;&#9;}&#10;&#10;&#9;System.out.println(&quot;\nExecution time: &quot; + executionTime + &quot; ms&quot;);&#10;&#10;&#9;scanner.close();&#10;    }&#10;&#10;    // Wariant 1: Thread - jeden wątek zlicza jeden znak&#10;    // Tworzy wątki dla każdego możliwego znaku (ograniczone przez numberOfThreads)&#10;    private static void runVariant1(int numberOfThreads, Obraz image) {&#10;&#9;int numberOfCharacters = image.getNumChars();&#10;&#9;System.out.println(&quot;Liczba różnych znaków użytych w obrazie: &quot; + numberOfCharacters);&#10;&#10;&#9;// Utwórz tablicę wątków - jeden wątek na każdy znak&#10;&#9;Watek1_Thread[] threads = new Watek1_Thread[numberOfCharacters];&#10;&#10;&#9;// Utwórz i uruchom wątki dla wszystkich znaków&#10;&#9;for (int i = 0; i &lt; numberOfCharacters; i++) {&#10;&#9;    threads[i] = new Watek1_Thread(i, image);&#10;&#9;    threads[i].start();&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfCharacters; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 2: Runnable - podział 1D blokowy po znakach&#10;    // Znaki są dzielone na równe bloki między wątki&#10;    private static void runVariant2(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#9;int numberOfCharacters = image.getNumChars();&#10;&#9;int charactersPerThread = numberOfCharacters / numberOfThreads;&#10;&#9;int remainder = numberOfCharacters % numberOfThreads;&#10;&#10;&#9;int startIndex = 0;&#10;&#9;// Utwórz wątki z podziałem bloków znaków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    // Rozdziel resztę z dzielenia między pierwsze wątki&#10;&#9;    int extraCharacters = (i &lt; remainder) ? 1 : 0;&#10;&#9;    int endIndex = startIndex + charactersPerThread + extraCharacters;&#10;&#10;&#9;    threads[i] = new Thread(new Watek2_Runnable(startIndex, endIndex, image));&#10;&#9;    threads[i].start();&#10;&#10;&#9;    startIndex = endIndex;&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 3: Runnable - podział cykliczny wierszowy&#10;    // Wiersze są przydzielane cyklicznie (round-robin)&#10;    private static void runVariant3(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#10;&#9;// Utwórz wątki - każdy przetwarza co numberOfThreads-ty wiersz&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    threads[i] = new Thread(new Watek3_Runnable(i, numberOfThreads, image));&#10;&#9;    threads[i].start();&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 4: Runnable - podział kolumnowy blokowy&#10;    // Kolumny są dzielone na równe bloki między wątki&#10;    private static void runVariant4(int numberOfThreads, Obraz image) {&#10;&#9;Thread[] threads = new Thread[numberOfThreads];&#10;&#9;int numberOfColumns = image.getSize_m();&#10;&#9;int columnsPerThread = numberOfColumns / numberOfThreads;&#10;&#9;int remainder = numberOfColumns % numberOfThreads;&#10;&#10;&#9;int startColumn = 0;&#10;&#9;// Utwórz wątki z podziałem bloków kolumn&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    // Rozdziel resztę z dzielenia między pierwsze wątki&#10;&#9;    int extraColumns = (i &lt; remainder) ? 1 : 0;&#10;&#9;    int endColumn = startColumn + columnsPerThread + extraColumns;&#10;&#10;&#9;    threads[i] = new Thread(new Watek4_Runnable(startColumn, endColumn, image));&#10;&#9;    threads[i].start();&#10;&#10;&#9;    startColumn = endColumn;&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; numberOfThreads; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;    // Wariant 5: Runnable - podział 2D blokowy&#10;    // Tablica jest dzielona na prostokątne bloki 2D&#10;    // Liczba wątków jest zaokrąglana do najbliższej siatki (np. 7 wątków -&gt; siatka 2x3 = 6 wątków)&#10;    private static void runVariant5(int numberOfThreads, Obraz image) {&#10;&#9;int numberOfRows = image.getSize_n();&#10;&#9;int numberOfColumns = image.getSize_m();&#10;&#10;&#9;// Dla prostoty: dzielimy na siatki (np. 2x2, 2x3, itd.)&#10;&#9;// Oblicz optymalny układ wątków w siatce 2D&#10;&#9;int threadsSqrt = (int) Math.sqrt(numberOfThreads);&#10;&#9;int threadsInRows = threadsSqrt;&#10;&#9;int threadsInColumns = (numberOfThreads + threadsSqrt - 1) / threadsSqrt;&#10;&#9;int actualThreadCount = threadsInRows * threadsInColumns;&#10;&#10;&#9;Thread[] threads = new Thread[actualThreadCount];&#10;&#10;&#9;int rowsPerThread = numberOfRows / threadsInRows;&#10;&#9;int columnsPerThread = numberOfColumns / threadsInColumns;&#10;&#10;&#9;int threadIndex = 0;&#10;&#9;// Utwórz wątki dla każdego bloku w siatce 2D&#10;&#9;for (int i = 0; i &lt; threadsInRows; i++) {&#10;&#9;    for (int j = 0; j &lt; threadsInColumns; j++) {&#10;&#9;&#9;// Oblicz granice bloku dla tego wątku&#10;&#9;&#9;int startRow = i * rowsPerThread;&#10;&#9;&#9;int endRow = (i == threadsInRows - 1) ? numberOfRows : (i + 1) * rowsPerThread;&#10;&#9;&#9;int startColumn = j * columnsPerThread;&#10;&#9;&#9;int endColumn = (j == threadsInColumns - 1) ? numberOfColumns : (j + 1) * columnsPerThread;&#10;&#10;&#9;&#9;// Utwórz wątek Runnable dla tego bloku&#10;&#9;&#9;threads[threadIndex] = new Thread(new Watek5_Runnable(startRow, endRow, startColumn, endColumn, image));&#10;&#9;&#9;threads[threadIndex].start();&#10;&#9;&#9;threadIndex++;&#10;&#9;    }&#10;&#9;}&#10;&#10;&#9;// Czekaj na zakończenie wszystkich wątków&#10;&#9;for (int i = 0; i &lt; actualThreadCount; i++) {&#10;&#9;    try {&#10;&#9;&#9;threads[i].join();&#10;&#9;    } catch (InterruptedException e) {&#10;&#9;&#9;e.printStackTrace();&#10;&#9;    }&#10;&#9;}&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Main.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.Arrays;&#10;import java.util.Random;&#10;import java.util.Scanner;&#10;&#10;public class Main {&#10;    &#10;    public static void main(String[] args) {&#10;        Scanner scanner = new Scanner(System.in);&#10;        &#10;        while (true) {&#10;            System.out.println(&quot;\n=== MENU DEMONSTRACJI PROGRAMOWANIA RÓWNOLEGŁEGO ===&quot;);&#10;            System.out.println(&quot;3.0 - Obliczanie całki (sekwencyjne i równoległe)&quot;);&#10;            System.out.println(&quot;4.0 - Sortowanie przez scalanie (ForkJoinPool)&quot;);&#10;            System.out.println(&quot;4.5 - Obliczanie całki z interfejsem Runnable&quot;);&#10;            System.out.println(&quot;5.0 - Histogram równoległy (pula wątków)&quot;);&#10;            System.out.println(&quot;0   - Wyjście&quot;);&#10;            System.out.print(&quot;\nWybierz opcję: &quot;);&#10;            &#10;            String choice = scanner.nextLine();&#10;            &#10;            try {&#10;                switch (choice) {&#10;                    case &quot;3.0&quot;:&#10;                        demonstrateIntegralCalculation(scanner);&#10;                        break;&#10;                    case &quot;4.0&quot;:&#10;                        demonstrateMergeSort(scanner);&#10;                        break;&#10;                    case &quot;4.5&quot;:&#10;                        demonstrateIntegralWithRunnable(scanner);&#10;                        break;&#10;                    case &quot;5.0&quot;:&#10;                        demonstrateParallelHistogram(scanner);&#10;                        break;&#10;                    case &quot;0&quot;:&#10;                        System.out.println(&quot;Koniec programu.&quot;);&#10;                        scanner.close();&#10;                        return;&#10;                    default:&#10;                        System.out.println(&quot;Nieprawidłowa opcja. Spróbuj ponownie.&quot;);&#10;                }&#10;            } catch (Exception e) {&#10;                System.out.println(&quot;Wystąpił błąd: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;    &#10;    private static void demonstrateIntegralCalculation(Scanner scanner) throws Exception {&#10;        System.out.println(&quot;\n=== OBLICZANIE CAŁKI: ∫(x²)dx ===&quot;);&#10;        &#10;        System.out.print(&quot;Podaj dolną granicę całkowania (a): &quot;);&#10;        double a = Double.parseDouble(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj górną granicę całkowania (b): &quot;);&#10;        double b = Double.parseDouble(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj krok całkowania (dx): &quot;);&#10;        double dx = Double.parseDouble(scanner.nextLine());&#10;        &#10;        // Sequential calculation&#10;        System.out.println(&quot;\n--- Wariant sekwencyjny ---&quot;);&#10;        CalkaSequential sequential = new CalkaSequential(a, b, dx);&#10;        long startTime = System.currentTimeMillis();&#10;        double resultSeq = sequential.calculate();&#10;        long endTime = System.currentTimeMillis();&#10;        System.out.println(&quot;Wynik: &quot; + resultSeq);&#10;        System.out.println(&quot;Czas: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;        &#10;        // Parallel calculation with ExecutorService&#10;        System.out.print(&quot;\nPodaj liczbę wątków dla obliczeń równoległych: &quot;);&#10;        int numThreads = Integer.parseInt(scanner.nextLine());&#10;        &#10;        System.out.println(&quot;\n--- Wariant równoległy (ExecutorService + Callable + Future) ---&quot;);&#10;        CalkaParallel parallel = new CalkaParallel(a, b, dx, numThreads);&#10;        startTime = System.currentTimeMillis();&#10;        double resultPar = parallel.calculate();&#10;        endTime = System.currentTimeMillis();&#10;        System.out.println(&quot;Wynik: &quot; + resultPar);&#10;        System.out.println(&quot;Czas: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;        &#10;        System.out.println(&quot;\nRóżnica między wynikami: &quot; + Math.abs(resultSeq - resultPar));&#10;        System.out.println(&quot;Wartość analityczna (x³/3): &quot; + ((b*b*b/3) - (a*a*a/3)));&#10;    }&#10;    &#10;    private static void demonstrateMergeSort(Scanner scanner) {&#10;        System.out.println(&quot;\n=== SORTOWANIE PRZEZ SCALANIE (ForkJoinPool) ===&quot;);&#10;        &#10;        System.out.print(&quot;Podaj rozmiar tablicy do posortowania: &quot;);&#10;        int size = Integer.parseInt(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj zakres wartości (max): &quot;);&#10;        int maxValue = Integer.parseInt(scanner.nextLine());&#10;        &#10;        // Generate random array&#10;        Random random = new Random();&#10;        int[] array = new int[size];&#10;        for (int i = 0; i &lt; size; i++) {&#10;            array[i] = random.nextInt(maxValue);&#10;        }&#10;        &#10;        if (size &lt;= 20) {&#10;            System.out.println(&quot;Tablica przed sortowaniem: &quot; + Arrays.toString(array));&#10;        } else {&#10;            System.out.println(&quot;Pierwsze 20 elementów przed sortowaniem: &quot; + &#10;                Arrays.toString(Arrays.copyOf(array, 20)));&#10;        }&#10;        &#10;        long startTime = System.currentTimeMillis();&#10;        int[] sorted = MergeSortDemo.sortWithForkJoin(array);&#10;        long endTime = System.currentTimeMillis();&#10;        &#10;        if (size &lt;= 20) {&#10;            System.out.println(&quot;Tablica po sortowaniu:    &quot; + Arrays.toString(sorted));&#10;        } else {&#10;            System.out.println(&quot;Pierwsze 20 elementów po sortowaniu:  &quot; + &#10;                Arrays.toString(Arrays.copyOf(sorted, 20)));&#10;        }&#10;        &#10;        System.out.println(&quot;Czas sortowania: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;        &#10;        // Verify if sorted&#10;        boolean isSorted = true;&#10;        for (int i = 0; i &lt; sorted.length - 1; i++) {&#10;            if (sorted[i] &gt; sorted[i + 1]) {&#10;                isSorted = false;&#10;                break;&#10;            }&#10;        }&#10;        System.out.println(&quot;Tablica posortowana poprawnie: &quot; + (isSorted ? &quot;TAK&quot; : &quot;NIE&quot;));&#10;    }&#10;    &#10;    private static void demonstrateIntegralWithRunnable(Scanner scanner) throws Exception {&#10;        System.out.println(&quot;\n=== OBLICZANIE CAŁKI Z INTERFEJSEM RUNNABLE ===&quot;);&#10;        System.out.println(&quot;(Wyniki przekazywane przez pole w obiekcie zamiast Future)&quot;);&#10;        &#10;        System.out.print(&quot;Podaj dolną granicę całkowania (a): &quot;);&#10;        double a = Double.parseDouble(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj górną granicę całkowania (b): &quot;);&#10;        double b = Double.parseDouble(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj krok całkowania (dx): &quot;);&#10;        double dx = Double.parseDouble(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj liczbę wątków: &quot;);&#10;        int numThreads = Integer.parseInt(scanner.nextLine());&#10;        &#10;        CalkaRunnableParallel runnableCalc = new CalkaRunnableParallel(a, b, dx, numThreads);&#10;        long startTime = System.currentTimeMillis();&#10;        double result = runnableCalc.calculate();&#10;        long endTime = System.currentTimeMillis();&#10;        &#10;        System.out.println(&quot;\nWynik: &quot; + result);&#10;        System.out.println(&quot;Czas: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;        System.out.println(&quot;Wartość analityczna (x³/3): &quot; + ((b*b*b/3) - (a*a*a/3)));&#10;    }&#10;    &#10;    private static void demonstrateParallelHistogram(Scanner scanner) throws Exception {&#10;        System.out.println(&quot;\n=== HISTOGRAM RÓWNOLEGŁY (ThreadPoolExecutor) ===&quot;);&#10;        &#10;        System.out.print(&quot;Podaj rozmiar danych: &quot;);&#10;        int size = Integer.parseInt(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj zakres wartości (0 - max): &quot;);&#10;        int maxValue = Integer.parseInt(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj liczbę przedziałów histogramu: &quot;);&#10;        int numBins = Integer.parseInt(scanner.nextLine());&#10;        &#10;        System.out.print(&quot;Podaj liczbę wątków: &quot;);&#10;        int numThreads = Integer.parseInt(scanner.nextLine());&#10;        &#10;        // Generate random data&#10;        Random random = new Random();&#10;        int[] data = new int[size];&#10;        for (int i = 0; i &lt; size; i++) {&#10;            data[i] = random.nextInt(maxValue + 1);&#10;        }&#10;        &#10;        System.out.println(&quot;\nGenerowanie histogramu dla &quot; + size + &quot; elementów...&quot;);&#10;        &#10;        HistogramParallel histogram = new HistogramParallel(data, numBins, numThreads);&#10;        long startTime = System.currentTimeMillis();&#10;        int[] result = histogram.calculate();&#10;        long endTime = System.currentTimeMillis();&#10;        &#10;        histogram.printHistogram(result);&#10;        System.out.println(&quot;\nCzas obliczeń: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;        &#10;        // Verify&#10;        int total = 0;&#10;        for (int count : result) {&#10;            total += count;&#10;        }&#10;        System.out.println(&quot;Suma elementów w histogramie: &quot; + total + &quot; (oczekiwano: &quot; + size + &quot;)&quot;);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/MergeSortDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/MergeSortDemo.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import java.util.Arrays;&#10;import java.util.concurrent.ForkJoinPool;&#10;&#10;public class MergeSortDemo {&#10;    &#10;    public static int[] sortWithForkJoin(int[] array) {&#10;        ForkJoinPool pool = new ForkJoinPool();&#10;        int[] result = pool.invoke(new DivideTask(array));&#10;        pool.shutdown();&#10;        return result;&#10;    }&#10;    &#10;    public static void demonstrateSorting(int[] array) {&#10;        System.out.println(&quot;Original array: &quot; + Arrays.toString(array));&#10;        &#10;        long startTime = System.currentTimeMillis();&#10;        int[] sorted = sortWithForkJoin(array);&#10;        long endTime = System.currentTimeMillis();&#10;        &#10;        System.out.println(&quot;Sorted array:   &quot; + Arrays.toString(sorted));&#10;        System.out.println(&quot;Time taken: &quot; + (endTime - startTime) + &quot; ms&quot;);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Obraz.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Obraz.java" />
              <option name="originalContent" value="import  java.util.Random;&#10;&#10;public class Obraz {&#10;&#10;    private int numberOfRows;             // Liczba wierszy tablicy&#10;    private int numberOfColumns;          // Liczba kolumn tablicy&#10;    private char[][] imageTable;          // Tablica 2D zawierająca znaki obrazu&#10;    private char[] symbolsArray;          // Tablica wszystkich możliwych symboli ASCII (ograniczona do numberOfCharacters)&#10;    private int[] histogram;              // Histogram - tablica z liczbą wystąpień każdego znaku&#10;    private int numberOfCharacters;       // Liczba różnych znaków używanych (dla wariantu 1)&#10;&#10;    // rows - liczba wierszy&#10;    // columns - liczba kolumn&#10;    // numberOfThreads - liczba wątków (określa ile różnych znaków będzie użytych)&#10;    public Obraz(int rows, int columns, int numberOfThreads) {&#10;&#10;&#9;this.numberOfRows = rows;&#10;&#9;this.numberOfColumns = columns;&#10;&#10;&#9;// Dla wariantu 1: użyj tylko tyle znaków ile wątków (min 1, max 94)&#10;&#9;this.numberOfCharacters = Math.max(1, Math.min(numberOfThreads, 94));&#10;&#10;&#9;imageTable = new char[rows][columns];&#10;&#9;symbolsArray = new char[numberOfCharacters];  // Tylko numberOfCharacters znaków zamiast 94&#10;&#10;&#9;final Random random = new Random();&#10;&#9;&#10;&#9;// Inicjalizacja tablicy symboli ASCII - tylko numberOfCharacters pierwszych znaków&#10;&#9;// 33 = '!', 126 = '~'&#10;&#9;for(int k=0; k&lt;numberOfCharacters; k++) {&#10;&#9;    symbolsArray[k] = (char)(k+33);&#10;&#9;}&#10;&#10;&#9;// Wypełnienie tablicy obrazu losowymi znakami z ograniczonego zbioru&#10;&#9;for(int row=0; row&lt;rows; row++) {&#10;&#9;    for(int col=0; col&lt;columns; col++) {&#10;&#9;&#9;imageTable[row][col] = symbolsArray[random.nextInt(numberOfCharacters)];  // losowy znak z numberOfCharacters znaków&#10;&#9;&#9;System.out.print(imageTable[row][col]+&quot; &quot;);&#10;&#9;    }&#10;&#9;    System.out.print(&quot;\n&quot;);&#10;&#9;}&#10;&#9;System.out.print(&quot;\n\n&quot;); &#10;&#9;&#10;&#9;// Inicjalizacja histogramu - tylko dla używanych znaków&#10;&#9;histogram = new int[numberOfCharacters];&#10;   &#9;clear_histogram();&#10;    }&#10;    &#10;    // Zeruje histogram (ustawia wszystkie wartości na 0)&#10;    public void clear_histogram(){&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) histogram[i]=0;&#10;    }&#10;&#10;    // Sekwencyjna wersja obliczania histogramu.&#10;    // Przeszukuje całą tablicę i zlicza wystąpienia każdego znaku.&#10;    //&#10;    // Uwaga: Ta metoda używa bardziej ogólnego podejścia (porównanie znaków)&#10;    // zamiast optymalnego (bezpośrednie indeksowanie), aby umożliwić&#10;    // zrównoleglenie w dziedzinie znaków ASCII.&#10;    public void calculate_histogram(){&#10;&#10;&#9;  for(int row=0; row&lt;numberOfRows; row++) {&#10;&#9;    for(int col=0; col&lt;numberOfColumns; col++) {&#10;&#10;&#9;&#9;// OPTYMALNA WERSJA (zakomentowana):&#10;&#9;&#9;// Bezpośrednie przekształcenie znaku na indeks histogramu&#10;&#9;&#9;// histogram[(int)imageTable[row][col]-33]++;&#10;&#10;&#9;&#9;// OGÓLNA WERSJA (używana):&#10;&#9;&#9;// Porównanie z każdym znakiem - pozwala na zrównoleglenie po znakach&#10;&#9;&#9;// Wątek może przeszukiwać tablicę dla konkretnego podzbioru znaków&#10;&#9;&#9;  for(int charIndex=0; charIndex&lt;numberOfCharacters; charIndex++) {&#10;&#9;&#9;    if(imageTable[row][col] == symbolsArray[charIndex]) histogram[charIndex]++;&#10;&#9;&#9;  }&#10;&#10;&#9;    }&#10;&#9;  }&#10;&#10;    }&#10;&#10;// UNIWERSALNY WZORZEC dla różnych wariantów zrównoleglenia:&#10;// Można go modyfikować dla różnych strategii dekompozycji albo stosować&#10;// bezpośrednio, zmieniając tylko parametry wywołania w wątkach&#10;//&#10;// calculate_histogram_wzorzec(startRow, endRow, rowStep,&#10;//                              startColumn, endColumn, columnStep,&#10;//                              startCharacter, endCharacter, characterStep){&#10;//&#10;//   for(int row=startRow; row&lt;endRow; row+=rowStep) {&#10;//      for(int col=startColumn; col&lt;endColumn; col+=columnStep) {&#10;//         for(int charIndex=startCharacter; charIndex&lt;endCharacter; charIndex+=characterStep) {&#10;//            if(imageTable[row][col] == symbolsArray[charIndex]) histogram[charIndex]++;&#10;//&#10;// Przykłady użycia wzorca:&#10;// - Podział wierszowy blokowy:    (0, rows/2, 1,   0, columns, 1,   0, 94, 1)&#10;// - Podział wierszowy cykliczny:  (0, rows, 4,     0, columns, 1,   0, 94, 1)  // dla 4 wątków&#10;// - Podział po znakach:           (0, rows, 1,     0, columns, 1,   0, 47, 1)  // pierwsza połowa znaków&#10;&#10;    // Wyświetla histogram - dla każdego znaku ASCII wypisuje jego symbol i liczbę wystąpień&#10;    // Format: 5 kolumn w wierszu dla lepszej czytelności&#10;    public void print_histogram(){&#10;&#9;&#10;&#9;int columnsPerRow = 5;  // Liczba kolumn w wierszu&#10;&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) {&#10;&#9;    // Wypisz znak i jego liczbę wystąpień&#10;&#9;    System.out.printf(&quot;%c: %-6d\t&quot;, symbolsArray[i], histogram[i]);&#10;&#10;&#9;    // Po 5 kolumnach przejdź do nowej linii&#10;&#9;    if ((i + 1) % columnsPerRow == 0) {&#10;&#9;&#9;System.out.println();&#10;&#9;    }&#10;&#9;}&#10;&#10;&#9;// Jeśli ostatni wiersz nie był pełny, dodaj nową linię&#10;&#9;if (numberOfCharacters % columnsPerRow != 0) {&#10;&#9;    System.out.println();&#10;&#9;}&#10;&#10;    }&#10;&#10;    // Wyświetla histogram w formacie liniowym (znak po znaku), pomijając znaki z wartością 0&#10;    // Używane dla wariantów 2-5 z pełnym zakresem znaków ASCII&#10;    public void print_histogram_filtered(){&#10;&#10;&#9;System.out.println(&quot;\nFiltered histogram (non-zero values only):&quot;);&#10;&#9;int count = 0;&#10;&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) {&#10;&#9;    // Wypisz tylko znaki, które występują w obrazie&#10;&#9;    if (histogram[i] &gt; 0) {&#10;&#9;&#9;System.out.println(symbolsArray[i] + &quot;: &quot; + histogram[i]);&#10;&#9;&#9;count++;&#10;&#9;    }&#10;&#9;}&#10;&#10;&#9;System.out.println(&quot;Total unique characters found: &quot; + count);&#10;    }&#10;&#10;    public int getSize_n() { return numberOfRows; }&#10;    public int getSize_m() { return numberOfColumns; }&#10;    public char[][] getTab() { return imageTable; }&#10;    public char[] getTab_symb() { return symbolsArray; }&#10;    public int[] getHistogram() { return histogram; }&#10;    public int getNumChars() { return numberOfCharacters; }  // Zwraca liczbę różnych znaków&#10;&#10;    // Zlicza liczbę unikalnych znaków występujących w obrazie&#10;    public int count_unique_chars() {&#10;        boolean[] found = new boolean[numberOfCharacters];  // Tablica flag dla każdego możliwego znaku&#10;        int count = 0;&#10;&#10;        // Sprawdź które znaki występują w tablicy&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                // Znajdź indeks znaku w tablicy symboli&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex] &amp;&amp; !found[charIndex]) {&#10;                        found[charIndex] = true;&#10;                        count++;&#10;                        break;  // Przerwij wewnętrzną pętlę po znalezieniu znaku&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return count;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import  java.util.Random;&#10;&#10;public class Obraz {&#10;&#10;    private int numberOfRows;             // Liczba wierszy tablicy&#10;    private int numberOfColumns;          // Liczba kolumn tablicy&#10;    private char[][] imageTable;          // Tablica 2D zawierająca znaki obrazu&#10;    private char[] symbolsArray;          // Tablica wszystkich możliwych symboli ASCII (ograniczona do numberOfCharacters)&#10;    private int[] histogram;              // Histogram - tablica z liczbą wystąpień każdego znaku&#10;    private int numberOfCharacters;       // Liczba różnych znaków używanych (dla wariantu 1)&#10;&#10;    // rows - liczba wierszy&#10;    // columns - liczba kolumn&#10;    // numberOfThreads - liczba wątków (określa ile różnych znaków będzie użytych)&#10;    public Obraz(int rows, int columns, int numberOfThreads) {&#10;&#10;&#9;this.numberOfRows = rows;&#10;&#9;this.numberOfColumns = columns;&#10;&#10;&#9;// Dla wariantu 1: użyj tylko tyle znaków ile wątków (min 1, max 94)&#10;&#9;this.numberOfCharacters = Math.max(1, Math.min(numberOfThreads, 94));&#10;&#10;&#9;imageTable = new char[rows][columns];&#10;&#9;symbolsArray = new char[numberOfCharacters];  // Tylko numberOfCharacters znaków zamiast 94&#10;&#10;&#9;final Random random = new Random();&#10;&#9;&#10;&#9;// Inicjalizacja tablicy symboli ASCII - tylko numberOfCharacters pierwszych znaków&#10;&#9;// 33 = '!', 126 = '~'&#10;&#9;for(int k=0; k&lt;numberOfCharacters; k++) {&#10;&#9;    symbolsArray[k] = (char)(k+33);&#10;&#9;}&#10;&#10;&#9;// Wypełnienie tablicy obrazu losowymi znakami z ograniczonego zbioru&#10;&#9;for(int row=0; row&lt;rows; row++) {&#10;&#9;    for(int col=0; col&lt;columns; col++) {&#10;&#9;&#9;imageTable[row][col] = symbolsArray[random.nextInt(numberOfCharacters)];  // losowy znak z numberOfCharacters znaków&#10;&#9;&#9;System.out.print(imageTable[row][col]+&quot; &quot;);&#10;&#9;    }&#10;&#9;    System.out.print(&quot;\n&quot;);&#10;&#9;}&#10;&#9;System.out.print(&quot;\n\n&quot;); &#10;&#9;&#10;&#9;// Inicjalizacja histogramu - tylko dla używanych znaków&#10;&#9;histogram = new int[numberOfCharacters];&#10;   &#9;clear_histogram();&#10;    }&#10;    &#10;    // Zeruje histogram (ustawia wszystkie wartości na 0)&#10;    public void clear_histogram(){&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) histogram[i]=0;&#10;    }&#10;&#10;    // Sekwencyjna wersja obliczania histogramu.&#10;    // Przeszukuje całą tablicę i zlicza wystąpienia każdego znaku.&#10;    //&#10;    // Uwaga: Ta metoda używa bardziej ogólnego podejścia (porównanie znaków)&#10;    // zamiast optymalnego (bezpośrednie indeksowanie), aby umożliwić&#10;    // zrównoleglenie w dziedzinie znaków ASCII.&#10;    public void calculate_histogram(){&#10;&#10;&#9;  for(int row=0; row&lt;numberOfRows; row++) {&#10;&#9;    for(int col=0; col&lt;numberOfColumns; col++) {&#10;&#10;&#9;&#9;// OPTYMALNA WERSJA (zakomentowana):&#10;&#9;&#9;// Bezpośrednie przekształcenie znaku na indeks histogramu&#10;&#9;&#9;// histogram[(int)imageTable[row][col]-33]++;&#10;&#10;&#9;&#9;// OGÓLNA WERSJA (używana):&#10;&#9;&#9;// Porównanie z każdym znakiem - pozwala na zrównoleglenie po znakach&#10;&#9;&#9;// Wątek może przeszukiwać tablicę dla konkretnego podzbioru znaków&#10;&#9;&#9;  for(int charIndex=0; charIndex&lt;numberOfCharacters; charIndex++) {&#10;&#9;&#9;    if(imageTable[row][col] == symbolsArray[charIndex]) histogram[charIndex]++;&#10;&#9;&#9;  }&#10;&#10;&#9;    }&#10;&#9;  }&#10;&#10;    }&#10;&#10;// UNIWERSALNY WZORZEC dla różnych wariantów zrównoleglenia:&#10;// Można go modyfikować dla różnych strategii dekompozycji albo stosować&#10;// bezpośrednio, zmieniając tylko parametry wywołania w wątkach&#10;//&#10;// calculate_histogram_wzorzec(startRow, endRow, rowStep,&#10;//                              startColumn, endColumn, columnStep,&#10;//                              startCharacter, endCharacter, characterStep){&#10;//&#10;//   for(int row=startRow; row&lt;endRow; row+=rowStep) {&#10;//      for(int col=startColumn; col&lt;endColumn; col+=columnStep) {&#10;//         for(int charIndex=startCharacter; charIndex&lt;endCharacter; charIndex+=characterStep) {&#10;//            if(imageTable[row][col] == symbolsArray[charIndex]) histogram[charIndex]++;&#10;//&#10;// Przykłady użycia wzorca:&#10;// - Podział wierszowy blokowy:    (0, rows/2, 1,   0, columns, 1,   0, 94, 1)&#10;// - Podział wierszowy cykliczny:  (0, rows, 4,     0, columns, 1,   0, 94, 1)  // dla 4 wątków&#10;// - Podział po znakach:           (0, rows, 1,     0, columns, 1,   0, 47, 1)  // pierwsza połowa znaków&#10;&#10;    // Wyświetla histogram - dla każdego znaku ASCII wypisuje jego symbol i liczbę wystąpień&#10;    // Format: 5 kolumn w wierszu dla lepszej czytelności&#10;    public void print_histogram(){&#10;&#9;&#10;&#9;int columnsPerRow = 5;  // Liczba kolumn w wierszu&#10;&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) {&#10;&#9;    // Wypisz znak i jego liczbę wystąpień&#10;&#9;    System.out.printf(&quot;%c: %-6d\t&quot;, symbolsArray[i], histogram[i]);&#10;&#10;&#9;    // Po 5 kolumnach przejdź do nowej linii&#10;&#9;    if ((i + 1) % columnsPerRow == 0) {&#10;&#9;&#9;System.out.println();&#10;&#9;    }&#10;&#9;}&#10;&#10;&#9;// Jeśli ostatni wiersz nie był pełny, dodaj nową linię&#10;&#9;if (numberOfCharacters % columnsPerRow != 0) {&#10;&#9;    System.out.println();&#10;&#9;}&#10;&#10;    }&#10;&#10;    // Wyświetla histogram w formacie liniowym (znak po znaku), pomijając znaki z wartością 0&#10;    // Używane dla wariantów 2-5 z pełnym zakresem znaków ASCII&#10;    public void print_histogram_filtered(){&#10;&#10;&#9;System.out.println(&quot;\nFiltered histogram (non-zero values only):&quot;);&#10;&#9;int count = 0;&#10;&#10;&#9;for(int i=0; i&lt;numberOfCharacters; i++) {&#10;&#9;    // Wypisz tylko znaki, które występują w obrazie&#10;&#9;    if (histogram[i] &gt; 0) {&#10;&#9;&#9;System.out.println(symbolsArray[i] + &quot;: &quot; + histogram[i]);&#10;&#9;&#9;count++;&#10;&#9;    }&#10;&#9;}&#10;&#10;&#9;System.out.println(&quot;Total unique characters found: &quot; + count);&#10;    }&#10;&#10;    public int getSize_n() { return numberOfRows; }&#10;    public int getSize_m() { return numberOfColumns; }&#10;    public char[][] getTab() { return imageTable; }&#10;    public char[] getTab_symb() { return symbolsArray; }&#10;    public int[] getHistogram() { return histogram; }&#10;    public int getNumChars() { return numberOfCharacters; }  // Zwraca liczbę różnych znaków&#10;&#10;    // Zlicza liczbę unikalnych znaków występujących w obrazie&#10;    public int count_unique_chars() {&#10;        boolean[] found = new boolean[numberOfCharacters];  // Tablica flag dla każdego możliwego znaku&#10;        int count = 0;&#10;&#10;        // Sprawdź które znaki występują w tablicy&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                // Znajdź indeks znaku w tablicy symboli&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex] &amp;&amp; !found[charIndex]) {&#10;                        found[charIndex] = true;&#10;                        count++;&#10;                        break;  // Przerwij wewnętrzną pętlę po znalezieniu znaku&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return count;&#10;    }&#10;    &#10;    // Wariant 1: Oblicza histogram dla jednego znaku (charIndex)&#10;    // Każdy wątek przetwarza osobny znak&#10;    public synchronized void calculate_histogram_for_char(int charIndex) {&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                    histogram[charIndex]++;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Wariant 2: Oblicza histogram dla bloku znaków (od startCharIndex do endCharIndex)&#10;    // Podział blokowy po znakach&#10;    public void calculate_histogram_block_chars(int startCharIndex, int endCharIndex) {&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                for (int charIndex = startCharIndex; charIndex &lt; endCharIndex; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        synchronized(histogram) {&#10;                            histogram[charIndex]++;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Wariant 3: Oblicza histogram dla co numberOfThreads-tego wiersza&#10;    // Podział cykliczny wierszowy&#10;    public void calculate_histogram_cyclic_rows(int threadId, int numberOfThreads) {&#10;        for (int row = threadId; row &lt; numberOfRows; row += numberOfThreads) {&#10;            for (int col = 0; col &lt; numberOfColumns; col++) {&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        synchronized(histogram) {&#10;                            histogram[charIndex]++;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Wariant 4: Oblicza histogram dla bloku kolumn (od startColumn do endColumn)&#10;    // Podział blokowy kolumnowy&#10;    public void calculate_histogram_block_columns(int startColumn, int endColumn) {&#10;        for (int row = 0; row &lt; numberOfRows; row++) {&#10;            for (int col = startColumn; col &lt; endColumn; col++) {&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        synchronized(histogram) {&#10;                            histogram[charIndex]++;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Wariant 5: Oblicza histogram dla bloku 2D (prostokąt określony przez wiersze i kolumny)&#10;    // Podział 2D blokowy&#10;    public void calculate_histogram_2D_block(int startRow, int endRow, int startColumn, int endColumn) {&#10;        for (int row = startRow; row &lt; endRow; row++) {&#10;            for (int col = startColumn; col &lt; endColumn; col++) {&#10;                for (int charIndex = 0; charIndex &lt; numberOfCharacters; charIndex++) {&#10;                    if (imageTable[row][col] == symbolsArray[charIndex]) {&#10;                        synchronized(histogram) {&#10;                            histogram[charIndex]++;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Watek1_Thread.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Watek1_Thread.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class Watek1_Thread extends Thread {&#10;    private int charIndex;&#10;    private Obraz image;&#10;    &#10;    public Watek1_Thread(int charIndex, Obraz image) {&#10;        this.charIndex = charIndex;&#10;        this.image = image;&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        image.calculate_histogram_for_char(charIndex);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Watek2_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Watek2_Runnable.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class Watek2_Runnable implements Runnable {&#10;    private int startCharIndex;&#10;    private int endCharIndex;&#10;    private Obraz image;&#10;    &#10;    public Watek2_Runnable(int startCharIndex, int endCharIndex, Obraz image) {&#10;        this.startCharIndex = startCharIndex;&#10;        this.endCharIndex = endCharIndex;&#10;        this.image = image;&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        image.calculate_histogram_block_chars(startCharIndex, endCharIndex);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Watek3_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Watek3_Runnable.java" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class Watek3_Runnable implements Runnable {&#10;    private int threadId;&#10;    private int numberOfThreads;&#10;    private Obraz image;&#10;    &#10;    public Watek3_Runnable(int threadId, int numberOfThreads, Obraz image) {&#10;        this.threadId = threadId;&#10;        this.numberOfThreads = numberOfThreads;&#10;        this.image = image;&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        image.calculate_histogram_cyclic_rows(threadId, numberOfThreads);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Watek4_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Watek4_Runnable.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class Watek4_Runnable implements Runnable {&#10;    private int startColumn;&#10;    private int endColumn;&#10;    private Obraz image;&#10;    &#10;    public Watek4_Runnable(int startColumn, int endColumn, Obraz image) {&#10;        this.startColumn = startColumn;&#10;        this.endColumn = endColumn;&#10;        this.image = image;&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        image.calculate_histogram_block_columns(startColumn, endColumn);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Watek5_Runnable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Watek5_Runnable.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;public class Watek5_Runnable implements Runnable {&#10;    private int startRow;&#10;    private int endRow;&#10;    private int startColumn;&#10;    private int endColumn;&#10;    private Obraz image;&#10;    &#10;    public Watek5_Runnable(int startRow, int endRow, int startColumn, int endColumn, Obraz image) {&#10;        this.startRow = startRow;&#10;        this.endRow = endRow;&#10;        this.startColumn = startColumn;&#10;        this.endColumn = endColumn;&#10;        this.image = image;&#10;    }&#10;    &#10;    @Override&#10;    public void run() {&#10;        image.calculate_histogram_2D_block(startRow, endRow, startColumn, endColumn);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>